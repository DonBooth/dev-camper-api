Git Hub:
https://github.com/PacktPublishing/Node.js-API-Masterclass-with-Express-and-MongoDB



https://learning-oreilly-com.ezproxy.torontopubliclibrary.ca/videos/node-js-api-masterclass/9781800569638/9781800569638-video1_1/
an O'Reilly course via Toronto Public Library.
Node.js API Masterclass with Express and mongodb



<<<=====   POPULATE   =====>>>


BELOW IS THE TEXT FROM THE COURSE
===========================================================================================

SENDING JWT IN A COOKIE 

Okay. So right now we have register and login set up, where we send a token back to the client and the client could store this in local storage. And then we're going to create some middleware so that it can be sent in the headers. But I also want to be able to send a cookie with this token so that can be stored in the browser, because in some cases storing in the cookie would be safer than storing it in local storage. So we're going to set that up, and we're going to use a package called cookie parser. And just to take a quick look at that, let me just open that up. So if we search for cookie-parser node. And let's see. Okay. So parse Cookie header and populate. So basically it's going to give us the availability of req.cookies with an object keyed by the cookie names. So we want to just install it and then enable the middleware by running it through app.use. And then we'll have access to req.cookie and we can set our token inside of a cookie, and then we can validate it when it comes back to the server. So let's jump into our terminal down here. I'm just going to stop the server for a second and install cookie-parser. [no audio] All right. And then we'll run the server again, and then let's go to server.js. And I'm going to go right below where we brought in the file upload and just say const cookieParser, and we'll set that to require, [Author Typing] cookie-parser. And then we just need to add the middleware. So let's go right here. [Author Typing] And just say app.use [Author Typing] (cookieBarder) cookie parser. Okay, so now what we'll do is go into our auth.js controller, and noticing in register and login, we have both of these lines where we get the token from the model, from the method in the model, and then we send back the response. Okay? So right here as well. So I'm going to actually create just a custom function here, that will get token from model. Also create cookie and send response. Okay. So we'll call this sendTokenResponse. And we're actually going to have a couple other routes that will use this later on. So this is going to take in a couple things. Now we're going to need access to the user, right? Because we need to call this, so we're going to parse in the user. We're going to need access to the status code. Okay? So we're sending a status code here which may be something different at some point. So let's say statusCode. And then we also need the response object in order to call res.status. So we need those things parsed in. Okay? Now I'm just going to grab this where we create the token, and put that in there, and then we're going proceed to create our cookie. So we're going to have some options here that we're going to parse in. [Author Typing] And we want to set the expiration of the cookie, which I want to set to the same expiration if we go to our config file, as the actual JSON web token which is 30 days. So in here we're going set another variable to JWT_cookie_expire. Now we can't do like 30 days here, we have to just do 30 like that. So we'll have to do a little bit of calculation within our code, but let's save that, and then let's restart the server so that that takes effect. Okay. And then back in our controller here, in the options we're going to set expires. Okay. And we're going to set it to a new date. And the date that we want to expire, it's going to be 30 days. Now in our config file, in our environment variable, we just have 30, that's all that's in there. So we have to specify that this is going to be 30 days. So we're going to say new Date, and then parse in date.now. Okay. Which will give us today's date and time, plus the 30 which is in process.env.jwt_cookie_ expire. And we want this to be 30 days, so we have to do *24*60*60*1000. So that should give us... (no audio) That should bring us to 30 days from this time. All right. We don't want a semicolon there. We actually want a comma. Okay. Now we only want the cookie to be accessed through the client side scripts. So we're going to set this httpOnly. We're going to set this to true. And then down here we're going to send our response. So we're going to do res.status. Remember this send token response will get parsed in statusCode. So we want to put that there. And then to send a cookie you can do res.cookie, and we can just tack it onto this. So I can just simply do .cookie. Actually let's put this on a separate line too. So res and then we have .status and then .cookie. And this is going to take in three things; it's going to take in the key. So basically what is the cookie called? I'm going to call it token, and then the value, which is going to be the token itself. And then the options, which includes like the expiration and stuff like that. Okay. And then we want to send some JSON data, so we can just do .json, and let's do our success : true. [Author Typing] And then we're going to send the token. Okay? So we're sending the token back in the response, we're also setting a cookie. And then it's really up to the client side what, how they want to handle it. So let's save that. Now, in order to call this sendTokenResponse, we're going to go up here, and let's see we want to replace this. Get rid of that. And we can just now do sendTokenResponse which is going to take in the user. It's going to take in the status code, which is going to be 200, and the response object. All right. Now, I'll just copy that, and we'll put this up here as well, replace these two lines. All right. So hopefully that makes sense. It's still doing the same thing it was doing, but in addition to that, it's going to be sending a token; I'm sorry, a cookie with the token in it. All right. So let's try that out. Let's go to Postman and let's try to log in here. Now with Postman, you can actually see the cookies right here. You can see there's nothing here right now. So I'm going to go ahead and log in. And now, notice we get the same response back we did before, and if we look in cookies, now we have a cookie by the name of token, we have it's value. Now it expires on Sunday November 3rd, and today is actually October 4th. So we can see that that's working, and then we also have our httpOnly, which is true. Now we do have the Secure flag set to false. Basically, if we set the Secure flag, the cookie will be sent with https. Now we can set that, but I only want to set it if it's in production. so let's go, let's actually do that. So back down here, right under where we have our options, let's say, if... Remember we can always check what environment we're in. So if we say, if (process.env.NODE_ENV) === 'production'. Then let's go ahead and take the options object, and let's set the secure property or create the secure property and set that to true. So that way when we're in production, we have that secure flag on our cookie. Okay. So our response is all set. Now in the next video, we need to create a piece of middleware to actually validate the token. Because right now we can send it, and the way we send it is in the headers, which I will show you in the next video. But we need to be able to validate that and and access the payload. Okay. So we're going work on that in the next video.





AUTH PROTECT MIDDLEWARE 

All right guys. So, we're able to log in or register and get a token. If I go ahead and log in with John Doe, we get back a token, and what we're going to do now is create a piece of middleware that will make it. So, we have to send this token to certain routes, like create a new bootcamp, a logged in users should be able to create a new bootcamp but not someone that's a guess that's not logged in. And we'll deal with roles later, right now we're not dealing with roles yet. So, what we would do is take the token, typically it would be stored in either local storage or a cookie on the client side. And then when we make the request to create a new bootcamp in the Headers, we would send along an Authorization header with that token. Now, typically we would do Bearer space and then the token, this is the convention for what's called the Bearer token, we're bearing this token. All right, so we need to be able to extract to get this in our application and extract the user ID from the token. And then, look that user up and put that into a request variable. All right, so that might sound confusing, but it'll make more sense as we move along. So, let's create inside middleware, a new file called auth.js. Okay, and this auth.js is going to have a couple of different functions that we're going to export. The one we're working on now is the protect function or the protect middleware and it's used to protect routes. So, let's bring in jwt because we need that in order to verify the token. [Author Typing] So, jsonwebtoken, and let's also bring in our asyncHandler because we're going to need that. [Author Typing] And that's in the same folder, same ./async and then let's bring in our ErrorResponse. [Author Typing] Okay, so that's going to be ../utils/errorResponse. And then finally, we'll bring in our User model because we need to look up the user [Author Typing] by the ID that's in the token. [Author Typing] All right. And then, let's say, Protect routes. So, we want to do exports a function called protect. And we're going to use our asyncHandler, passing in async function with request, response, next. [Author Typing] Okay, and then we want to initialize a variable called token, and now we want to check the headers. Okay, we want to check for that Authorization header, which I just showed you, so this right here. Now, we can access any headers we want with request.headers. So, let's say, if requests.headers. And then, we want the authorization header. Okay, now we also want to make sure it's formatted correctly with Bearer space token. So, we're going to do double ampersand if req.headers.authorization .startsWith('Bearer'). Okay. So, we want to check those two things and if that's true, then let's go ahead and set the token. Now, we just want the token part, we don't want the Bearer because it's going to be formatted like this Bearer space. So, the way I'm going to extract it is by turning this into an array where Bearer is the first item and the token is the second. And then, I'll just grab the token, so we can use the split method to do that. So, let's say, requests.headers. authorizations.split We're going to split at the space because its Bearer space token, and we want the second item which is going to be in the one index. Okay, so that will give us the token. Now, we have the ability to use cookies, but I don't want to add that functionality just yet because for our all of our testing we're not going to use cookies. So, I guess what I'll do is I'll put it here, but I'll comment it out. So, have else if [Author Typing] and then check req.cookies. [no audio] I'm trying to think of how I should do this. Yeah, I guess we'll just do it this way. So, cookies.token and if that's true, then token will be set with request.cookies.token. But I'm going to go ahead and comment this out because I don't want to deal with it right now. All right, so we'll get the token from the headers and we want to make sure that it's actually sent. So, make sure token is sent or we should say, make sure token exists whether it's through cookies or through the authorization. So, we do that by just saying if not token then let's go ahead and return next and say new ErrorResponse. And we're going to say, Not authorize to access this route or this... Yeah, I guess this route. And then, that's going to be a 401 which is unauthorized. All right, so now if the token does exist we need to verify it. So, let's actually put this in a try catch. [Author Typing] So, say verify token. And what we're going to do is extract the payload from it, and the payload is going to look like this. It's an object with the User ID it also have like an issued at, which will be something the timestamp it was issued at and the expiration. All right, in fact I'll console log it once we decode it. So, let's say, const decoded, and we're going to set this to jwt which has a method called verify, and that takes in two things, the token itself and the secret. Remember the secret is inside a config files, so we can access it like this. It has to be the same secret that it was signed with. And then, I'm just going to console log decoded so that when this runs you can see it and then this decoded object is going to have an ID property which is the User ID. So, we want to set a new req.user value to await and then we want to findById and use that decoded.id. Okay, so whatever ID is in that token which the user got by logging in with correct credentials, that's going to be passed in here and then that's going to be set to this req.user. Okay, so this will always be the logged, that the logged in user, currently logged in user. And then, we just want to call next. Okay, and if something happens to throw this error down here, we're just going to do the same thing. All right, so let's save that. Now, wherever we want to use this in our routes, let's go to our bootcamp routes. We need to just add it as a first parameter before the method. So, we need to bring in the protect middleware first. So, let's say, const and I'm just going to destruction and bring in protect. Okay, the protect function from [Author Typing] the middleware/auth. And we don't want to protect this route. This is to get the radius, you know, bootcamps by radius. Upload a photo, we do want to protect that. So, we simply add it like that, getBootcamps we don't need to protect that, createBootcamps we do. Just going to copy this. And then down here to update and delete, we want to protect as well. So, wherever you put protect the user has to be logged in. So, let's save that and then I'm going to copy this where we brought in the middleware and go to courses, courses routes and do the same thing. So, we want to protect addCourse [Author Typing] and we want to protect update and deleteCourse. All right, so go ahead and save that. So now, if we go to try to add a bootcamp, I'm going to take this authorization out and in the body let's just do... Let's see, I think what's required, let's just replace the name with TEST BOOTCAMP. All right, so I'm going to try to 'Send' this now. And check out what we get back a 401 Unauthorized and then Not authorized to access this route, because we didn't send a token, we didn't send a valid token. So, what we can do now is login as a user. I have john doe in the database, so a login and grab the token and then go to back to the 'Create New Bootcamp', and in the Headers will add Authorization and then we want to do Bearer space and then the token. Now before I send this, I'm going to change this by taking the zero off the end and putting a one and let's see what happens. We still get not authorized. So, if this was verified, and it didn't pass. So, let's put the 0 back and let's send and now I created a new bootcamp, TEST BOOTCAMP. And if we look at the console where I did the... where I console logged the decoded, I hope that's not it. See right here. So, once we passed in the token to verify this decoded is this, it has this id property which is the user id from that token. And then we just got the user and we put it into request.users. So, now in any route where we use that middleware we have access to request.user in any of the user fields. So, what I'm going to do now is create one route inside auth inside are auth controllers, I should say one method, I'm going to go under login and under just under everything. Let's grab a signature though, so grab that. And what I want to do is create a route to get the current logged in user. [Author Typing] So, this is actually going to be auth/me and this is going to be Private. So, you need a token to access this and let's say exports.getMe. And we're going to set this to use are asyncHandler. [Author Typing] So, with this getMe now since this is we're using the protect route where we have access now to request.user which is always going to be the logged in user. So, I'm just going to set a variable here to user and set it to await User.findById. And we'll simply pass in request.user and get the id of the logged in user. And then we're going to send back a response [Author Typing] of (200).jason success true. And the data is going to be the user. All right so, let's 'Save' that and then let's create a route for it. So, we're going to go to routes auth.js and let's see in here. Let's create just 'Copy' this down. So, this is going to be a get request to /me and we're going to call getMe which we have to bring in.... Over here. [Author Typing] So, now let's go back to Postman and let's do auth/me make a GET request. We don't need to send anything here in the body. We don't need to but we do need to send the header. So, let's grab John Doe's token and inside the header let's do Authorization Bearer space and then is token and 'Send,' "Cannot read property of 'id' of undefined?" Let's see. All right, so it looks like request.user is not defined. We didn't add the protect middleware. So, in auth in our router right here we need to add to protect middleware so, we have to bring it in [Author Typing] because it's long if you don't add that middleware then that request.user is not going to be available. So, we want to require auth so, then we just want to add here protect oops I'm sorry. We want to add it on this side. So, let's try that. So, we'll go back. So, we have our auth/getMe and we're sending in the token for John Doe And there we go. So, we get back the whole user. Notice the password isn't there because we did select false in the model for the password. We don't want to return the password even though it's hashed it's encrypted. We still don't want to return it. So, let's 'Save' this as a 'Get Logged in User via token.' All right and now, just to prove it to you that this works if we register another user. So, go to the 'Body.' And let's do me I'll just say brad@gmail and I'll just send. So, now we'll take this token. It doesn't matter if I registered or logged in as brad. I'd get a token with my id and now if I go back to this Get Logged in User and I put in my token and 'Send' now I get my user. Now doing this for every route that we want to....That we want to access. That's protected is kind of pain in the neck. So, in the next video, I'm going to show you how we can automatically Login without having to manually enter this header Authorization here. We can actually use this tab here. I'm going to show you how to use this. So, basically when we Login that token will automatically get stored and Postman and we can use it through here. So, we'll do that next.





STORING THE TOKEN IN POSTMAN 

All right guys, now I'm going to show you nerd or trick in Postman, because we have the functionality where we have our protect Middleware so we can send an Authorization and the Header with the Bearer Token of a logged in user to access certain routes. But this is kind of a pane to have to do this in every single route. So, if I wanted to Delete a BootCamp, I'd have to add Headers, Authorization, put in the token and so on and I don't want to have to do that. So, what we can do is in the Login User route, we can go into, Tests right here and we can actually create an environment variable based of something in the response. Okay. So, in here I'm going to do pm.environment.set. Okay. So, this is going to set an environment variable, remember if we look in here, we have a URL r in our environment variable. What I want to do is put our token once we login in into there and I want to do it automatically. So, inside this set, hopefully you guys can see this. I'm going to create a variable called "TOKEN" Okay. And then the second parameter here is going to be 'pm' so postman.response.jason().token. Okay. Because remember when we login we get a value called token and I'm taking that and putting that into an environment variable. So, I'm going to go ahead and save this and I'm going to do the same thing with Register because remember, Register gives us a token as well. So, let's go there and go to Tests and paste that in and save. Okay, So now let's go ahead and re-login. So, let's see in our Body, I have john@gmail so I'm going to login and now if we look up here in our variables, check that out. The token is automatically put in there. Okay? And if I login as brad which is another user in the database and we look at that now, that token is put in there. Now to use this token in protected routes, such as this one here to get a logged in user. All we have to do is we no longer need this. We can actually get rid of that. We just need to go to Authorization and simply choose Bearer Token. And then in here, actually that should get put in automatically. Maybe not. We have to put that in so we just want to put in our token variable like that. All right. So, now let's send and it gets the correct login user and just save this so that this is always set. All right, then you don't have to do anything here in the Headers. So, if I go and login back as John. [Author Typing] Okay. So, login and I go back to this route and send it gets John because that Authorization, that Bearer Token, it's looking at the environment variable which is being set as soon as I login or register. Okay. And you want to do the same thing for any protected routes. So, for instance to delete a Bootcamp, let's actually delete the one we created in the last video. So, if I get all Bootcamps, we should have one called Test this one right here. I want to delete meet this. So, if I take this ID and I go to Delete Boot Camp and I put this in here, it's not going to work right now, I'm going to get a rejection because we're not authenticated. We have to actually go to Authorization and choose Bearer Token. And it actually that now remembers the environment variable. So, now if I go and I send now it's deleted. Okay. And I'm just going to save this. All right. And we want to do the same with like create new Boot Camp. Will choose Bearer Token and save, do it with update Boot Camp. [Author Typing] Bearer Token save. So, this way we don't have to do anything really. We just need to login or register and then we can access these routes. Okay. We'll do the same with upload photo. Any routes that are protected, save that. And then for courses, we have let's see create course [Author Typing] save, update [Author Clicking] and delete. [Author Clicking] Okay. And then any future routes that are protected. We're going to do that same thing. So, really really cool trick. Its really saves us a lot of times. We don't have to keep copying the token after we login or register and then putting it in the headers. It's just automatically set for us. All right, so that's it. I'll see you in the next video.









ROLE AUTHORIZATION 

All right guys, so now I want to add the middleware function to authorize certain roles to do certain things. So, if we look at our database, right here in the users, you'll see that I have two users: John Doe and myself. And, we both have the role of publisher. So, I'm actually going to just edit this to user. So, I'm now going to be just a user, and we're going go and create this middleware in our auth.js file inside our middleware. We have our protect function. We're going to go underneath protect and create a new function to Grant access to specific roles. So, we're going to do exports.authorize. And, this is going to actually take in some roles, and we're going to use the spread operator here because, what's going to get passed in here is a comma separated value list of roles like publisher, admin or something like that. So, that will get passed in and then, we need to return our middleware function, which is going to have req, res, next [Author Typing] and then what I want to do put that there, what I want to do is, check to see if the currently logged in user, which we can get with req.user because we set that right here. I want to see if it includes, if the role is included in what's passed in here. So, we can do that by saying if not we're going to check if not roles.includes and then pass in the req.user.roles, I'm sorry, role. Because each user has a role property. So, we're checking that. It will be either user, admin, or publisher. And we're going to see if it's included in the roles that are passed in. If it's not, then we want to return an error response. So, I'm just going to copy that. Now, I'm going to actually put in some back ticks here, because I want to say user role, and then I want to output the actual users role. So, req.user.role is unauthorized to commit this action. No, let's do access this route, just like we did before. user role and then the role is not authorized [Author Typing] to access this route. And it's going to be 403, which is a forbidden error. And then, we just want to go... let's see, right underneath the if statement here and just call next. Don't put your next down here, or it's going to hang. So, just make sure you put it here. Now, let's save this. And now, go into our routes. So, we'll go to routes bootcamps.js, and just like we brought in protect, we're going to bring in authorize. And then, remember only a publisher and an admin can create bootcamps and manage bootcamp. And right here, so bootcampPhotoUpload, we want to put after protect, authorize and then we can pass in the roles that are allowed to do this, which are going to be publisher, [Author Typing] or admin. Now, make sure you put authorize after protect because if we look in our authorize, we're using req.user and that gets set right here in the protect middleware. So, you want to make sure you have this in the correct order. Now, I'm just going to copy this, and go down to where we create a bootcamp, and we want to paste that in there, as well as update, and as well as delete. So, we'll save that. And then, let's go into our courses routes and bring in authorize, [Author Typing] and we want to add that here for addCourse, updateCourse, and deleteCourse. So, now what I'll do is go back to Postman and let's log in as my user, Brad, or whoever you set as a regular user and not a publisher. So, I logged in, and that token got saved to the environment variable. Now, I'm going to go to create a new bootcamp and in the body, looks like I already have "Test" in here, so we'll use that. Let's send, and I get a 403 forbidden. It says, "User role user is not authorized to access this route." Now, if I go and I log in as John, who is a publisher, [Author Typing] let's go ahead, and send that. So, now that token is stored. And, if I try to create that same bootcamp with John, it works. So, that's successful. Now, I just want to delete this. So, I'm going to actually log back in as Brad and try to delete it, which I shouldn't be able to. [mouse clicking] So, if I get the id, which is right here, and go to delete bootcamp, paste in that id, and send, I can't do it, because I'm not a publisher. Now, I'm going to go into my database, and I'm going to change my user, the Brad user to an admin. [Author Typing] So, we'll update that. Now, if I send now it works, I was able to delete because now I'm an admin. So, it's pretty easy how we could implement roles like that, and you can create whatever roles you want, and basically add those roles to whatever routes you want. Now, always want to start to get into next is ownership because if we create a bootcamp right now, we're not actually entering the user with that bootcamp. So, any publisher or admin can create a bootcamp, but we don't know who created it. And there's no special permissions to say that only the owner can update, or delete that bootcamp. So right now, as long as they're logged in and they have the right role, they can manage any bootcamps they want and we don't want that. So, in the next video, we're going to start on access in permissions for specific bootcamps and courses.




BOOTCAMP & USER RELATIONSHIP

All right, so, now we want to create a relationship for users in bootcamps. If we look at our JSON data that we've been importing, you can see, there is a user ID. But inside of our model, our bootcamp model, we don't have that anywhere. So, we need to add that in order for that to be possible to have a user associated with the bootcamp. So, let's go ahead and add that. Now we've done this before with courses. If we look at our course model, we did it. So, we related a bootcamp to a course by using this mongoose.Schema.ObjectId. So, we can actually just grab this and put that here, and just call this user and it's going to be the same type which is mongoose.Schema.ObjectId, except now, we're dealing with the user model. All right, we can leave required true as well. So, now, there'll be a user associated with a bootcamp. Now, in order, I'm going to save this, and in order for that to happen, in order for a user to get inserted into this field, we have to edit our bootcamp controller. So, let's do that. We're going to go to where we create a new bootcamp, which is this route, right here. And we're going to, let's see... So, we're creating a bootcamp based off of what is in req.body. Now, the user ID, obviously, we're not going to submit that in the body. That's not going to come from the client, that's going to come from our middleware, where we, remember, we have access to that request.User? So, what we're going to do is, we'll just go to the top here, and say Add user. [no audio] I will say add user to body to req.body... And we can do that by just simply saying, req.body, will add user. And we're going to set that equal to req.user because remember, this is the logged in user and we want the Id from that user. So, now, when we go ahead and Bootcamp.create request body, it will now have the user on it. Now, while we're at it, let's add the functionality where a publisher or an admin can only add one bootcamp, okay? Because again, the idea is that a publisher is someone that works for the bootcamp that signs up to our website or our application and creates a listing for their bootcamp. So, let's go right under here, after we get the, actually no, let's go above it. And we want to just basically check, we'll say, 'Check for published bootcamps or bootcamp'. So, we'll create a variable called publishedBootcamp and we're going set this to await, and we're going to use our bootcamp model and do .findOne, and we want to find it by the user, okay? So, we're going to put in our curly braces and say, where the user is equal to the logged in user, which is req.user. And we want the ID. So, that will find all bootcamps by this user, okay? Any bootcamp that this user created. Now, we want to say, 'if the user is not an admin,' [Author typing] 'they can only add one bootcamp', okay? If they're an admin, then they can add as many as they want. So, to do this, let's do an if statement here. And we're going to say, 'if published bootcamp.' And so, what this means is, if published bootcamp is that there was already one found in the database. But we want to say, 'and if the req.user.role', because we're gonna access the role of the logged in user, if that is not equal to admin, okay? Because if it is equal to admin, that's fine, they can they can go ahead and add another one. But here, if they're not an admin, then, let's go ahead and let's 'return next' with a new error response. [no audio] And in here, we'll put in some back ticks and let's say, 'the user with ID.' And then, we can put the actual req.user.id, which is the logged in user, as 'already published a bootcamp', okay? And we'll send a 400 status code. So, that will take care of that functionality. And then, yeah, that the rest of this is just going to be the same. Okay, so let's save this and now, let's try it out. Before we actually hit the route and we try anything out. I just want to edit our database seeder because if we go to seeder.Js, we haven't implemented the users and I want to do that. I want to be able to load up the bootcamps, the courses and the users, and if we look in the data folder and the users.JSON, there's a bunch of users in here. We actually have john@gmail, which is what I've been using with the password, one through six. And all of the passwords are one through six. So, you can, you'll be able to log in as any of these users and some of them are publishers. And then, down here, you can see, some of them are users. I do have an admin@gmail. It's a user because when we import with this, this seeder, it goes through the model. And if you remember, we have an enum that, where it can only be a user or a publisher. For it to be an admin, you actually have to change that in the database itself. That's why I don't have admin here, it won't let us do that. Okay, it still adheres to all the rules in the model. So, let's add this to our seeder. So, in seeder.js, we're going to first, bring in the user model. [no audio] I mean, you don't have to do this, this stuff with the seeder and I just, I think it's helpful if we, if everybody has the same data throughout the course, but you know, if you don't want to use the seeder, you don't have to. So, this is going to be users. Make sure you change it here as well. And then, we want to create users with the user model. And when we delete data, we also want to delete all users. So, this will be user delete many. Actually, it should be capital. All right, so let's save that. And what I'm going to do is, is just clear out the database completely. So, I'm going to run 'node seeder -d'. Okay, so now, we should have nothing in the database and then, we'll run our server. And now, what I would like to do is, go ahead and add log in, or in this case, register because we just deleted all the users, and there's nothing in there. But let's register a user, and then, let's create a bootcamp and we should have that user associated with that bootcamp. So, we'll go to register, in the body, we'll go ahead and do john@gmail, John Doe, And make sure it's a publisher or we won't be able to create a bootcamp and then, we'll send, okay? So now, we should be logged in, in terms of Postman, we have the token in the variable here. And then, let's go to create new bootcamp and in the body, let's change this to 'ModernTech Bootcamp.' And we'll just leave all these fields. And of course, we're not submitting any user data here but it should automatically add the the user ID, because of the code we just wrote in the controller method, okay? And again, just make sure your authorization is, make sure bear token is selected and you have your token variable in here. So, let's send that, okay? And let's see what we get back. So, we get all of our bootcamp fields and if you check out, right here, user, we have the ID of John Doe. Okay now, let's try and add another bootcamp and we shouldn't be able to. So, I'm just going to change the name here, so we don't get a duplicate name error. We'll just add of one and we'll send, and we get the user with ID. ID has already published a bootcamp. So, that's working, we can only publish one bootcamp. And if we want to test the admin functionality, we can go right into... ..reconnect, here, we can go right into compass and we'll change the role to an admin and we should be able to add another one. [no audio] So, basically, on your, in your front-end, let's say, a react application, you would have an admin area for, you know, to add more than one bootcamp. So, let's go into devcamper and users, and we'll change John Doe, change his role to admin. And now, if I submit this ModernTech Bootcamp 1, it works, all right? And if I go back to compass and we check out bootcamps, we have both, ModernTech bootcamp and ModernTech 1, and you can see that the user, where's the user? The object ID here, is the same, okay? And we were only able to add a second one because it was an admin, all right? So I'm going to just get rid of the second one that I created, this ModernTech Bootcamp 1, we'll just delete that. And now, in the next video, I want to start to work with permissions, where, you know, you have to be the owner in order to update. Because right now, I could register a new user and I would be able to update this bootcamp, and I'll show you that and then, we'll add the code to fix that in the next video.



BOOTCAMP OWNERSHIP

All right. So, now we're going to work on permissions when it comes to updating and deleting Bootcamps because right now we have this ModernTech actually this isn't it? Let me just close this up and just show you if we say Get All Bootcamps. We have one in here called ModernTech Bootcamp and the user is John Doe. Now at the moment any user can update or delete this and I'm just going to give you an example of that. So, if I login, actually I think we only have one user, let's register another user. So, a brand new user, we'll call Kevin Smith and say kevin@gmail, all right. So, now we're logged in as Kevin because once we register it, it sends the token and it stores it in the environment variable. So, let's try to update that Bootcamp. 

So, I'm going to grab the ID [Author typing] Which is this. Make sure you get the bootcamp id, not the user ID and 'Copy' it. Let's go to 'Update' bootcamp and let's 'Paste' this in and then let's go to the body here, the raw JSON and let's change. Let's see what we got here. Let's change housing to true. So, we'll just go ahead and add in here, housing and we want to set that to true from false. So, 'Send' and we get a successful response and if we look at housing it's true. Now, we shouldn't be able to do that, right? Because this bootcamp belongs to John Doe, he added it so Kevin shouldn't be able to update it. So, let's jump into our controller. Okay, close that up and let's go to our bootcamp's controller and go down to our update, okay. So, we have our updateBootcamp and what we'll do is go right under where we check to see if the bootcamp exists and let's say make sure bootcamp or make sure user is bootcamp owner. So, to do that we can simply just say, if and we have access to the bootcamp and then we have access to user. Now, this here is actually going to give us an object ID and we want to compare this to the actual request.user.id which is a string. So, we want to turn this object ID into a string before we actually try to compare it. So, we're going to use the JavaScript method toString. [Author Typing] Okay, string is one T. All right. So, we're going to say toString and then if it's not equal to the request.user.id and we also want to throw in here if it's an if, if they're not an admin because if it's an admin then they should be able to update the Bootcamp regardless. So, we can just say if the request.user basically, the logged in user, if their role is not an admin. So, what we're saying here is if the user is the owner and also not an admin then we're going to send back an error. We're going to do return next. And I'll just 'Copy' this. So, we're going to return an ErrorResponse and we're just going to say user and then the user id 'is not authorized to update this bootcamp.' And then we're going to do a 401 status code. Now, I just realized something if we leave it like this it's not going to work because up here we did findByIdAndUpdate. So, it's going to update up here before it even gets to this. So, to get around that instead of findByIdAndUpdate, we're simply going to findById Which is just going to take in the ID we don't need this stuff here, okay. So, it's going to just find it. It's going to put it in here, we're going to check for it, then we're going to make sure that the user is the owner and then we'll do our findByIdAndUpdate. So, down here, we'll take that bootcamp variable. In fact, lets change this to let and then we'll set bootcamp equals await bootcamp.findByOneAndupdate and we want to pass in request.params.id. We want to update it with request.body and we also want to add the options of new True. So, it returns the updated bootcamp and we also want to runValidators, set that to true, okay and then that will be stored in here and then we can return our response with updated content. So, let's 'Save' that and now, let's go back and we're currently logged in as Kevin, who's not the owner and let's try to set this to false, housing to false. And we get an error 401 that says, "User is not authorized to update this bootcamp." Lets login as John Doe who is the owner. So, go ahead and 'Send' that. Login tokens got stored, we'll go to update and 'Send' and now housing is false, Okay. Now, we want to do the same exact thing for delete. So, let's check out delete and see what we have. So, this is okay, we're just finding the bootcamp and then we're doing the remove down here. So, I'm just going to 'Copy' what we did right here where we're making sure that this is the owner and put it right above the remove. All Right. So, just checking to see if the bootcamp.user, the id in the database is equal to the user id, the logged in user id and that it's not an admin. And if that's true then we're going to return this error here except let's change update to delete and that should do it. So, let's 'Save' that and let's try it out. I'm going to login as Kevin who is not the owner and then go to 'Update.' I'm sorry not update. Now, we want to do 'Delete.' So, let's make sure we grab the Id. Go to our 'Delete' route, put that id in there and try to 'Delete' and we're not allowed to, all right. Let's login with John. [Author typing] So, now we're logged in as John, we go to 'Delete,' 'Send' and it gets deleted. Okay and if we get all bootcamps now we should have none in the database, good. So, that's how we can add our permissions and make it. So, only the owner or an admin can update or delete a bootcamp. Now, in the next video we want to do pretty much the same thing we just did in this video and the last one, but for courses, okay. Courses should also have a user associated with them and only the owner of the course and the bootcamp should be able to update and delete. All right guys real quick, I just forgot the photo upload method. We want to make sure that the user owns the bootcamp and able to upload a photo. So, we're just going to grab this right here and this is from the update. So, we're just going to 'Copy' that, we're going to go to the photo upload route, which is right here and we're going to go ahead and put this right under here where we check to see if the bootcamp exists. So, we'll just 'Paste' that right in and we shouldn't have to change anything except for the message. We'll just say, actually we can keep this message because technically we're updating bootcamp. So, I'm just going to 'Save' that and we should be all set. So, now in the next video, we'll start to work on courses.


COURSE OWNERSHIP

All right, so now we pretty much want to do the same thing we did for bootcamps for courses. So, let's jump into VS Code, and let's go into our course model. And we want to add a relationship with the user model. So, I'll actually just copy this, and change this to user, and change this to User. And we'll save that. And then let's go into our controller, our courses controller, and go to add courses, or add course I should say. And here is where we want to add that functionality. Now just like we got the bootcamp ID from the params, and put it in the body, now we're going to get from the request.user.id, and put that in the body. So, request.body.user = req.user.id, same thing we did with the bootcamp. And then let's go down here. So, we're finding by ID, by ID, checking to see if it's there, if the bootcamp is there. Then we're creating a course with that bootcamp. But before we do that, let's go ahead and make sure that we add the user, or actually I'm sorry, let's make sure that the bootcamp owner is the user that's logged in. So, I'm going to grab from the bootcamp controller. Let's grab this, where is it? Right here, so we're making sure it's the bootcamp owner. We're going to grab that, and put that right in here, because remember a course is associated with a bootcamp, so you want the owner of the bootcamp to be able to add the course. Not just anybody should be able to add a course to a specific bootcamp, unless they're admin, that's why we have this right here. So, I don't think there's anything that we have to change here, except for the message. So, we want to say user whatever is not authorized to add a course to... we could even put the bootcamp ID in here. To be more specific we could say, add a course to bootcamp, bootcamp. _id, so that should work. So, let's save that, and let's try it out. So, in Postman, we'll log in as John, and we don't have any bootcamps at the moment, so let's create one, we'll say 'Create new bootcamp' we'll just use this [Author Typing] I don't know why I saved it with test. I'm going to just change this to ModernTech Bootcamp, and save it. And then I'm going to create this with the user John, so you can see we have a user, where is it [no audio] right here, so that's the user ID. So, now let's take the ID of the bootcamp, and let's add a course to it. So, I'm going to go over to courses, and create course. Remember the route is going to be /bootcamp/, and then the ID of the bootcamp, so I'm going to paste that in, and we'll just go ahead, and keep the data I have saved in here. And I'll send, and it should work, because I'm logged in as John, who is the bootcamp owner. Now if I log in as Kevin, and I go to create course, and I'll just add a one onto this and send, we get user, okay, so we're getting undefined, but it says is not authorized to add a course to bootcamp, and then the ID. So, let's see why that says undefined. And it says undefined because this should actually be user.id. So, if I send it again, there we go. So, it tells us the user ID, and they're not allowed to update, I'm sorry, to add a course to this bootcamp. So, we got that down, now let's take care of the update and delete. So, we'll go back into our courses controller, and then let's go down. Actually, you know what we'll do is we'll just copy this, and go down to our update course. So, we're finding it up here. And then before we update it, let's paste this in, and let's say 'Make sure user is course owner'. So, we'll say course.user is equal to the logged in user, and not an admin. And if that fails, then we'll say 'User whatever is not authorized to add a course', or we'll say 'Is not authorized to update course'. And then we can put the course ID. You don't have to do this, put the actual ID in but, why not? And then we'll grab that, we'll do the same thing for the delete. So, we want to put that right above the remove, and we'll just change this to delete. So, now we'll go back to Postman, and I believe we're still logged in as Kevin, who is not this... Is not the course owner, actually let me just get the courses. Okay, so we have our full stack web development. Let's take the course ID, and let's go to update course, and put in that ID, and then in the body, I'll just keep this data, it doesn't really matter. We'll send, and we can't update it. Okay, let's try the delete. We'll put in the ID, and send, and we can't delete it. Now if we log in as John, the course owner, the course in bootcamp owner. And then we go to update, that works. If we go to delete, that works. Now if we check all courses, we shouldn't have any, which is this route here, okay good. So, everything is working how it should, and I apologize for all the tabs open. I know this might be a little confusing, but hopefully you can bear with me. All right, so we've done quite a bit. I think what I want to work on next, now that we have our authentication, we have our permissions for bootcamps and courses, and so on. So, what I want to get into next is the forgot password functionality. We want to be able to hit a route if we forget a password, get an email sent to us to reset the password with a special reset token that we're going to hash. And then they can use that route to reset their password, okay? So, that's what we'll get into next.





====

Forgot Password - Generate Token

All right guys, so in this video we're going to start on the forgot password functionality and the reset password, where they can send their email and an email will actually get sent to them with a specific token that they can use in order to reset their password. So, in this video we're going to handle the functionality where they can send an email to a route, forgot password route, and we're going to generate a token. We're going to hash it and put it into the database into this field right here, reset password token. We're also going to set an expiration. All right, and then in the next video we'll continue with the actual email sending functionality. All right, so the first thing I'm going to do is just seed the database with all of our data. So, our seeder.Js at this point should be bringing in all the Bootcamps, the courses, and the users from these Json files. So, I'm just going to run node seeder -d, and then node seeder -I. Okay, so now we should have all the data in the database, and we're going to run our server. All right, so inside of Js in our controller, let's go down to the bottom. In fact, this send token response, this is a helper function we're using it's not an actual controller method hooked to a route, so I'm going to cut this and put it at the very bottom, underneath all of our route handlers. Okay, and then I'm going to just copy this get me route, put that here, and just change this to forgot password. And the route is going to be post to auth, forgot password, it's going to be public, [no audio] and let's change the name. Okay, and then what we want to do first is get the user by the email that's sent in the body. So, we're going to use find one. And instead of passing in the ID, we want to pass in an object and we want to match the email to the request.body.email, that's set. All right, And then after we do that. Let's see, we're going to want to check for that user. So, let's say if there is no user with that email, then let's return, next. And say new error response. [no audio] I will say, [Author Typing] "There's no user with that email". All right, and we're going to send a 404 status code back, and that should be a comma. Okay, and then we want to get our reset token. So, we're going to create a variable here called reset token. And we're actually going to have a method inside of our model. So, we can call that on the user itself, and we're going to call that get reset password token. Okay, so I'm going to save this and jump into our models, our user model. And basically we want to fill these two fields right here. And we're going to use core module called crypto to generate the token and to hash it. So, let's bring in crypto require crypto. Okay, and then down at the bottom here. So, we're going to go right above the exports and create, let's say generate and #password token. So, we'll say user schema, and since this is, it's being called on the user itself, not on the model itself. So, it's a method instead of statics, we're going to do methods, and then it's called geRtesetPasswordToken. [no audio] So, function and here, the first thing we're going to do is generate the token. So, we'll say const reset token and let's set this to crypto, which has a method called random bytes which will just generate some random data and the parameter, where the argument we want to pass in here is going to be the number of bytes which I'm going to do 20. Now, this will give us a buffer, we will actually want to format it as a string so we're going to say to string and we're going to pass in here hex. So, that will give us the reset token. Now, we want to hash the token and we also want to set it, we'll say hash token and set to, what's the field called? ResetPasswordToken field. Now, remember this is a method being called on the actual users so we can access the user's fields with this. So, reset password token. And we want to set that not just to the reset token but to the hash version of it. That's what we want to actually store in the database. So, we can say crypto dot, and then there's a method called createHash which takes in the algorithm we want to use which is going to be shot 256, and then we do dot update and pass in what we want to hash which is going to be the original reset token. And then we just want to digest it as a string, as a hex string. So, we want to pass and digest hex. And this is all in the node crypto documentation. So, underneath that make sure you're still within the method here. We want to then set the expire. So, remember there's a field called resetPasswordExpire and we want to set that to 10 minutes. So, we'll say date.now, plus 10, times 60, times 1,000. And that will give us 10 minutes. And then we simply want to return the original reset token. Okay, not the hash version, just the original token. Okay, so we'll save that. All right, so this reset token is now going to be stored in this variable. So, I'm just going to console.log this for now, and just hit this route and see what happens. Just to see if make sure we generate this. So, we have to create this. We have to in our routes file. So, routes auth Js, and bring, make sure you bring in forgot password. And then down here we're going to add the route, it's not going to use the protect middleware. So, in here we'll say forgot password and this is going to be a post request. And it's going to be to /forgotpassword. All right, so we'll save that. Let's open up Postman, and let's just create a new tab here. It's going to be a post request to our URL/api/.v1/auth, and then forgot password. And we want to make sure we send in the headers, our json content type because in the body, we're sending the email. Okay, and what I'm going to do first is just send an email that doesn't exist. So, we'll say John one at gmail. And if I send that, we get back there is no user with that email 404, okay? If we get an email that is in the database, we're just going to get back the user. But you can see that the reset password token is in the database and this is the hashed version. We also have the expiration which is 10 minutes from now. Okay, so if you look at this is the hash version but in our console.log we get the, you know? What we got from random bytes. Okay, so the idea here is we store the hash version but when we send the email with the token, it's just going to be the regular version, okay? And then we'll just match it when they actually hit the reset password route. So, let's go back into our controller and finish this up. Now, even though we got the response with this reset password token, we didn't actually save it in the database. In fact, if I go here to compass and I reload and we look at john doe you see those fields are not saved in the database. So, back in our controller here, right under where we get the reset token, we want to save the user. So, we want to do await user.save, and we don't want to run any validators like check the name and all that stuff. So, in here we can pass in validate before save, and set that to false. So, now let's go back to Postman and let's hit this forgot password again. "Illegal arguments, undefined string". Let's see, I know what's going on. So, model user.js:42. 42, okay, so what's happening is this middleware is running because we are saving a user. But we don't have, we don't have a password, we didn't add a password. We're not doing that. So, what we can do to get around this is we can just put an if statement here, and there's a method we can run called is modified, and we can pass in a field such as password. Okay, but what we want to do actually is to make sure this is not. So, we want to say if not is modified password, then we just want to move along, so, next. All right, so this down here now will only run if the password was actually modified. So, let's save that and hopefully that fixes this issue. All right, so let's go back here and send, Okay, so we get the correct response and let's check our database for John Doe or reload this, and there we go. So, now we have the expiration and we have the hash token in John Doe's record here in the document. All right, so in the next video, we're going to continue on here in the controller and we want to set up our email. We want to be able to send an email with that token with a specific route that they can go to reset their password and they'll have 10 minutes to do it.


FORGOT PASSWORD - Generate Token

All right guys, so in this video we're going to start on the forgot password functionality and the reset password, where they can send their email and an email will actually get sent to them with a specific token that they can use in order to reset their password. So, in this video we're going to handle the functionality where they can send an email to a route, forgot password route, and we're going to generate a token. We're going to hash it and put it into the database into this field right here, reset password token. We're also going to set an expiration. All right, and then in the next video we'll continue with the actual email sending functionality. All right, so the first thing I'm going to do is just seed the database with all of our data. So, our seeder.Js at this point should be bringing in all the Bootcamps, the courses, and the users from these Json files. So, I'm just going to run node seeder -d, and then node seeder -I. Okay, so now we should have all the data in the database, and we're going to run our server. All right, so inside of Js in our controller, let's go down to the bottom. In fact, this send token response, this is a helper function we're using it's not an actual controller method hooked to a route, so I'm going to cut this and put it at the very bottom, underneath all of our route handlers. Okay, and then I'm going to just copy this get me route, put that here, and just change this to forgot password. And the route is going to be post to auth, forgot password, it's going to be public, [no audio] and let's change the name. Okay, and then what we want to do first is get the user by the email that's sent in the body. So, we're going to use find one. And instead of passing in the ID, we want to pass in an object and we want to match the email to the request.body.email, that's set. All right, And then after we do that. Let's see, we're going to want to check for that user. So, let's say if there is no user with that email, then let's return, next. And say new error response. [no audio] I will say, [Author Typing] "There's no user with that email". All right, and we're going to send a 404 status code back, and that should be a comma. Okay, and then we want to get our reset token. So, we're going to create a variable here called reset token. And we're actually going to have a method inside of our model. So, we can call that on the user itself, and we're going to call that get reset password token. Okay, so I'm going to save this and jump into our models, our user model. And basically we want to fill these two fields right here. And we're going to use core module called crypto to generate the token and to hash it. So, let's bring in crypto require crypto. Okay, and then down at the bottom here. So, we're going to go right above the exports and create, let's say generate and #password token. So, we'll say user schema, and since this is, it's being called on the user itself, not on the model itself. So, it's a method instead of statics, we're going to do methods, and then it's called geRtesetPasswordToken. [no audio] So, function and here, the first thing we're going to do is generate the token. So, we'll say const reset token and let's set this to crypto, which has a method called random bytes which will just generate some random data and the parameter, where the argument we want to pass in here is going to be the number of bytes which I'm going to do 20. Now, this will give us a buffer, we will actually want to format it as a string so we're going to say to string and we're going to pass in here hex. So, that will give us the reset token. Now, we want to hash the token and we also want to set it, we'll say hash token and set to, what's the field called? ResetPasswordToken field. Now, remember this is a method being called on the actual users so we can access the user's fields with this. So, reset password token. And we want to set that not just to the reset token but to the hash version of it. That's what we want to actually store in the database. So, we can say crypto dot, and then there's a method called createHash which takes in the algorithm we want to use which is going to be shot 256, and then we do dot update and pass in what we want to hash which is going to be the original reset token. And then we just want to digest it as a string, as a hex string. So, we want to pass and digest hex. And this is all in the node crypto documentation. So, underneath that make sure you're still within the method here. We want to then set the expire. So, remember there's a field called resetPasswordExpire and we want to set that to 10 minutes. So, we'll say date.now, plus 10, times 60, times 1,000. And that will give us 10 minutes. And then we simply want to return the original reset token. Okay, not the hash version, just the original token. Okay, so we'll save that. All right, so this reset token is now going to be stored in this variable. So, I'm just going to console.log this for now, and just hit this route and see what happens. Just to see if make sure we generate this. So, we have to create this. We have to in our routes file. So, routes auth Js, and bring, make sure you bring in forgot password. And then down here we're going to add the route, it's not going to use the protect middleware. So, in here we'll say forgot password and this is going to be a post request. And it's going to be to /forgotpassword. All right, so we'll save that. Let's open up Postman, and let's just create a new tab here. It's going to be a post request to our URL/api/.v1/auth, and then forgot password. And we want to make sure we send in the headers, our json content type because in the body, we're sending the email. Okay, and what I'm going to do first is just send an email that doesn't exist. So, we'll say John one at gmail. And if I send that, we get back there is no user with that email 404, okay? If we get an email that is in the database, we're just going to get back the user. But you can see that the reset password token is in the database and this is the hashed version. We also have the expiration which is 10 minutes from now. Okay, so if you look at this is the hash version but in our console.log we get the, you know? What we got from random bytes. Okay, so the idea here is we store the hash version but when we send the email with the token, it's just going to be the regular version, okay? And then we'll just match it when they actually hit the reset password route. So, let's go back into our controller and finish this up. Now, even though we got the response with this reset password token, we didn't actually save it in the database. In fact, if I go here to compass and I reload and we look at john doe you see those fields are not saved in the database. So, back in our controller here, right under where we get the reset token, we want to save the user. So, we want to do await user.save, and we don't want to run any validators like check the name and all that stuff. So, in here we can pass in validate before save, and set that to false. So, now let's go back to Postman and let's hit this forgot password again. "Illegal arguments, undefined string". Let's see, I know what's going on. So, model user.js:42. 42, okay, so what's happening is this middleware is running because we are saving a user. But we don't have, we don't have a password, we didn't add a password. We're not doing that. So, what we can do to get around this is we can just put an if statement here, and there's a method we can run called is modified, and we can pass in a field such as password. Okay, but what we want to do actually is to make sure this is not. So, we want to say if not is modified password, then we just want to move along, so, next. All right, so this down here now will only run if the password was actually modified. So, let's save that and hopefully that fixes this issue. All right, so let's go back here and send, Okay, so we get the correct response and let's check our database for John Doe or reload this, and there we go. So, now we have the expiration and we have the hash token in John Doe's record here in the document. All right, so in the next video, we're going to continue on here in the controller and we want to set up our email. We want to be able to send an email with that token with a specific route that they can go to reset their password and they'll have 10 minutes to do it.


FORGOT PASSWORD - SEND email

Okay. So now, we're going to start on the email sending with the Password Token that we created. And one thing I want to do before we do anything else is save this route, this 'forgotpassword'. So, I'm going to say 'Save as', 'Forgot Password.' And, so this route is going to 'Generate password token and send email' and we'll 'Save' that, okay. So, let's go back... Actually, I wanted to just show you what we're going to be using for this first. So, we're going to be using a package called Nodemailer, which is pretty popular for Node.js, in order to send emails. And if you go down here this is the documentation. It gives you an example, it's pretty easy. We can just create what's called a transporter and we can use different services; if you want to use Gmail, or if you're in production, I'd probably suggest like SendGrid or something like that. We're going to use something called Mailtrap, which is like a fake SMTP server for staging and development. So, we'll be able to have emails sent to our users but, we'll actually catch the emails in this Mailtrap. So, it's free. I mean, there are premium plans but, we definitely don't need that for what we're doing. So, just create an account. I'm going to go ahead and just log in. [Author Typing] And then, you'll get a mailbox created automatically. And then, you can see all the Credentials over here that you need, like the Username, Password, and so on. So, this stuff we're going to have to plugin to our transporter in Nodemailer. All right. So, this stuff I do want to put in our config file. So, let's go ahead and open that up. I'm just going to close that and that. And let's open up 'config.env'. So, in here, we're going to add our SMTP_HOST=. And, I tried to do this in a way where you could easily just swap it out for Gmail, or SendGrid, or whatever you want to use. So, we want our SMTP_PORT=. I'll put in the values after. We want the SMTP_EMAIL= or Username. SMTP_PASSWORD=. [Author Typing] We also want a FROM_EMAIL=, and a FROM_NAME=. Okay. So, the HOST, in this case, where I'm doing is =smtp.mailtrap.io. And then, the PORT=2525. The EMAIL... If you're using Mailtrap like I am, then you want to put your Username, which is right here. Okay, make sure you use your own, not mine because this probably won't exist after I record. So, we want to put that here. But if you are using let's say, Gmail. You would put your Gmail email there. The PASSWORD is going to be this. [no audio] Okay so, put that. And then, I'm going to use for my FROM_EMAIL=noreply@devcamper.io. That's the domain I actually plan on deploying to. And the NAME, I'll just say =DevCamper. All right. So, let's restart our servers, so that those take effect. Actually before we restart, let's install Nodemailer. So, npm i nodemailer. [Author Typing] All right. And then, we'll start our server, okay. Now, we're still working in this 'forgotPassword' controller method. But what I'm going to do is create a utility for sending emails. All right. So, in this 'utils' folder, let's create a 'New File' and call it 'sendEmail.Js'. Okay. And we're going to set this up much like this right here. I'm going to change it up a little bit but it's going to be pretty similar. So, let's go ahead and let's say, let's bring in nodemailer. Actually, we could probably just copy this. [no audio] We'll copy this. We don't need the bottom, this main().catch or the 'use strict';. But, let's just paste that in. So, we bring in nodemailer. I'm going to get rid of these comments though. And I'm also going to make this an arrow function. So, let's do... And let's change the name from main() to sendEmail. So, we'll say, const sendEmail = async. And, it's also going to take in... It's going to take in some options, okay. And then, we'll put an arrow function. And let's see, we don't need to create a testAccount, we'll get rid of that. We do want to create a transporter. So, I'm actually going to use const here. So, nodemailer.createTransport. The host is in our environment variables. So, process.env.SMTP_HOST. And then, I'm just going to copy this. And then, for the port, we're going to do PORT. secure, we're just going to get rid of this secure, we don't need that. And then, for the auth:, we want here our SMTP_EMAIL. And for the password, we want our PASSWORD. And just get rid of these comments. We're not using this ethereal. All right. So, that's our transporter. We'll just get rid of that. Okay. So now, down here, I'm going to set this up a bit different. I'm just going to create... Let's change this to 'message'. And, this is just going to be a plain object with some of this stuff. So, let's get rid of this await transporter.sendMail. I'm going to do this at the bottom afterwards. So, this is just an object and we're going to have a from:. And inside here, let's replace this. Actually, we'll just get rid of this whole thing here. So, from: and then we'll use some backticks because we want to use process.env.FROM_NAME. And then, we want to have some angle brackets. And then, we want our process.env.FROM_EMAIL. Okay. And now to: is going to come in from the options. I'm trying to make this as reusable as possible. So, let's go ahead and add to to: options.email. All right. And then the subject, same thing. That's going to come in from the options. So, options.subject. And then, the text is going to be options.message. And then, that's it. I'm not going to do the html here. Okay. So now, we just have this object. Next thing we're going to do is create that info variable and we're just going to set it to = await because this returns a promise. Our transport. I want to say transporter.sendMail. And we want to pass in that message. Okay, let's just change this to const. [Author Typing] All right. And then, let's see down here. Let's get rid of this stuff, we can get rid of this. And we'll just do a 'console.log('Message sent:', and it just says the 'messageId'. Okay so, I think... [no audio] I think we're good here. [no audio] transporter.sendMail, yes. Okay so, let's export this so that we can use it in another file [Author Typing] and we'll 'Save'. All right. So, let's go back to our auth controller and let's bring in that utility. So, I'm going to go right here and say, const sendEmail. And we want to 'require('../utils/sendEmail')'. And then, we'll go continue on down here in our 'forgotPassword' methods. So, the last thing we did was save the user. So now, we need to prepare some things to pass into our 'sendEmail' utility. One is going to be the reset URL that includes the token. So, let's say, // Create reset url. So, we'll say, const resetUrl. And we're going to set this to some backticks. Because I don't want to just send the token, I want them to have the the entire url which is going to be /ResetPassword/ and then, the token. So, let's get the actual protocol. So, http or https. So, req.protocol://. And then we can get the host or whatever the domain is with request.get and then host. Okay. So, that will give us the host and then we want to do /API/version1/reset password/ and then the reset token. [Author Typing] Okay. So, that will give us the reset URL. Now, we want to create a message to pass in. [Author Typing] So, let's say we going to use some back text. Now this will be different. If you had a front and with react, it would probably include a front end link that you would click to and you would go to. But in this case we don't have a front end application so what we're going to do in the email is just say, make a specific type of request to this URL to reset your password. And I'm actually going to just grab this and paste it in, because it's quite a bit of text. All right. So, it just says you're receiving this email because you or someone else has requested the reset of a password. Please make a PUT request to and then the reset, and it actually should be like that to reset you URL. Okay. That's the message we want. Now, we want to call the send email function from our utility. So, we going to put this in a try catch. Okay, and then inside the try here let's 'await, 'send email' which is going to take an options where it has that options which is going to be the email which is the user's email, so user dot email, whatever the email that's sent in the body here which is going to be this, user's email is going to be sent there. And then for the subject let's say 'password reset token.' And I could put this stuff in the send email function itself, but I wanted to make it as reusable as possible so you can put in whatever subject, whatever message you want. Okay. So, we want to put those three things and if everything works out, then we going to respond with a status of 200. And we're just going to do .Json and then a successful, say 'success true.' All right. And if you want... I mean, we could just do like data, say email sent just a string. And then down here, if something goes wrong, what we're going to want to do is get rid of those fields in the database, the reset password token and the reset password expire. Actually, we'll just log the error first and then we can just take our user and say 'resetPasswordToken.' Set that to undefined. Okay, we want to do the same with the XX expire. We don't want to leave that hanging around. All right. And then we'll save the user, so 'await user.save.' And we don't want to run the validators, so we going to going to say 'validateBeforeSave false.' And then we're going to just return an error, so 'next and new ErrorResponse,' and we'll just say reset... Or I'll just say 'email could not be sent' and that's going to be a 500 server error. All right. So, that's it. Let's save it and hopefully everything works out. So we have our mail traps set up. We have our send email utility that should get called. It should be sent this message with the reset URL. Okay. So, let's go back to postman and let's run our forgot password. Reset token... Oh, rest token. Where is that? So, this should be reset token. Let's try it again. Email could not be sent. Okay. So let's take a look down here. Email cannot be sent. [no audio] Something went wrong with our send email. [no audio] Wait send email... All right. So, let's take a look in here and see if I screwed something up. [Author Typing] And send email is not a function. I put a dash here. It should be an equal sign. All right. So, let's try that. Good. So, you notice it took like two seconds that's because the email is getting sent. We get success true emails sent. And now let's check out male trap. And I have this password reset token to john@gmail.com because that's the user we requested. And if we check it out, we get a message that says, you're receiving this email because you requested to reset, please make a put request to and it has the entire route. So, reset passwords/ and then the token. All right. So, now in the next video we need to handle this because right now this isn't going to do anything. What we need to happen, is we want to send the password, the new password to this URL and have it reset the password. And remember this is only going to last for 10 minutes, and you can change that if you want. So we're going to do that next.


RESET PASSWORD

All right. So, we're now able to hit at forget password route, get an email sent with the reset token. Now we want to create the route that we actually use the token with. So, let's create a new method in our off controller. I'm just going to copy that getMe here and I'm going to go right below the forgot password, just right here and paste that in. And let's change this to reset password and it's going to be a put request and it's going to be to auth/resetpassword and then it's going to take, the reset token as a parameter. All right and it's going to be public. So, let's change this to reset password. And the first thing we're going to do is get the token out of the URL and hash it because that's what we need to match, that's in the database it's going to be hash. So, let's let's see we'll just push this down for now and let's say get hashed token and we need to use crypto for that and I don't think that we brought that in, no we didn't. So, let's bring in crypto. [Author Typing ] Okay. And then [no audio] See we're going to say Const resetpassword [Author Typing] token and set that to crypto. and then same thing we did before, we wanted to do createHash ('Sha256'). And then we want to do dot update and we're going to pass in the token from the URL which is (req.params.resettoken) and then .digest('hex'). Okay. So, now we want to now find the user, actually can use this right here. We're going to find the user by the reset token and only if the expiration is greater than right now. All right. So, instead of find by ID, let's do find one and let's get rid of this. And we're going pass in an object with password reset. What do we call it reset password token which is what it's called in the database I believe if we look at our model. Reset password token. So, we can just leave that and then we want the reset password expire in the database, make sure that's greater than right now. So, we can do that with the g $gt operator. So, we'll say greater than Date.now. All right. So, that will get us the user by the token and we want to of course check to see if that exists. So, if not user then we want to return next [Author Typing] and let's just say ('Invalid token'). And that's going to be a 400. All right. So, if the if it does exist if we can find the user by the token and the token isn't expired then let's set the new password because they're going to send a new password in the body. So, we'll take the user and set the password equal to req.body.password. And it should get encrypted because of our malware because of you know this right here it is being modified. So, this won't this won't fire off and it will encrypt our password. So, then we just want to set these two fields to go to nothing to undefined. So, we'll say user.resetpasswordtoken=undefined [Author Typing] and also passwordExpire undefined. And when you set these and when you set a field to undefined it just goes away. Okay? So, then we just need to save the user, so wait user.save and as far as our response back we're going send back a token. So, basically they will be logged in. So, we're going to call this sendTokenResponse just like we did up here. I'll just grab it let's grab it from right here. [Author Typing] Okay. And then that's going to be where is it? It is resetPassword. caption So, after we save the user go ahead and send that. Okay . So, let's try it out. Let's first of all, this is going to be expired the one I already sent that was 19 minutes ago. So, let's just delete that from the mail drop. And then let's go to post mail and run forgot password. Okay . So, we get emails sent, let's check the email. Let's grab this route right here. I'm just going to copy that, go to Post mail and create a new tab and make a put request to that route. But we can change, we can just put our URL in here that's okay and then we want to send for headers or just in content type and in the body we want to send the new password. [Author Typing] So, password originally it was 123456. Let's set it to 12345. What should happen is, it should get to give us the token. So, basically log us in and change the password, which it didn't because we didn't add the route. So, in our routes auth.Js we need to bring in, resetPassword and we need to create that route. [Author Typing] resetPassword and see this is going to be a put [Author Typing] to [Author Typing] resetpassword and then we need the token. So, it's going to be //: resettoken. Okay let's try that. So, send this again [no audio] still didn't work. [no audio] He said password [no audio] to put [no audio] That's weird. [no audio] You said password [no audio] I'm not sure why this isn't working API version one. [no audio] I forgot Auth and we have to fix that in our forgot password. So, in our auth controller forgot password right here I forgot //auth. Okay . So, make sure you do that and now let's try this again. So, we get successful path password is short, it has to be six characters long. All right . So, let's change it to six seven, one through seven instead. So, we'll go ahead and send and there we go we get a token back. Okay . So, we're now we're logged in but let's just make sure that the password actually changed. So, I'm going to just save this as Reset Password and we'll just say Reset User Password using token and we'll save this to authentication, good. Now to check this let's go ahead and log in with john doe, let's try it with one through six. That shouldn't work anymore. Okay . Invalid credentials. The password now should be one through seven. And if we send that works and if we look at our database, if we reload, if we look at john doe the token is gone and the expiration is gone. Because once we reset it, see where we are, once we reset it we then set those two undefined and then we saved. Okay . So, it's not like the token and the expiration is going to just sit around in the database. It's just for the purpose of resetting. Okay . So, that functionality is done.



UPDATE USER DETAILS

All right, so now we want the user, the logged in user, to be able to update their name and email and also update their password, and these are going to be two separate routes. So, we are going to have a user's controller and users route and you could put this stuff in the user's controller, but I want that to be more for just the admin functionality to basically, crud functionality for users which only admins can do this is more for authentication, because it has to do with the current logged in user. At least that's how I like to see it if you want to set it up differently and put these routes in your user's route, you could do that but I'm going to use Auth. So, I'm going to go down and just copy.. the getMe, which is... where is it? Right here. [Author Typing] And actually we'll go right under it. [Author Typing] And this is to update... user details, and it's going to be a PUT request, [no audio] to auth/updatedetails, private and let's change the name here, updateDetails. Okay, so we're going to use findById and update but we don't want to just pass in request.body because then, if a password is sent or a route or any other user field that's in the module is sent it will actually update that. We don't want that, they should just be for the name and email. So, we're going to say const fieldsToUpdate is going to be the name, so req.body.name, email: request.body.email. All right, and then down here let's do findByIdAndUpdate, We'll pass in the ID, so this is the logged in user's id, and then fieldsToUpdate. All right, and then we'll pass in our new true and runValidators, we're going to set that to true as well, and then we'll just return we'll keep this. Okay, so let's save that. Let's add this to our route. So, we want to bring in from our controller updateDetails, I'm just going to copy this /me and change this to updatedetails, and we want this to be a PUT request. And it's going to keep the protect middleware and we're going to run updateDetails the method. So, let's go to Postman. And let's see... we'll create a new tab here, [Author Typing] it's going to be PUT [Author Typing] /auth/updatedetails and we're sending Json data so we need that. And let's send email, [Author Typing] John@gmail, [Author Typing] and then name, [Author Typing] let's do John Smith. All right, so we have to be logged in, so let's go to the Login tab and send that. So, the token gets stored and then let's choose authorization, bear token, okay, so that should be good, let's go ahead and try and send that. All right, good, so we get back a response with the user and we get John Smith. So, we can update that, we can also update the email if we want to do like John1 and send, you can see that that was updated, but I'm going to put it back to John, I'm also going to put it back to John Doe. [Author Typing] Okay, and let's just save this tab as Update User Details. And then in the description here we'll just say update logged in user name and email, okay? So, that's that. Now we want to do the update password. So, back in our controller. Let's copy the getMe function here again and we'll go right below the user details, and let's say update password. And this is also going to be a PUT request, [Author Typing] and it's going to be auth/updatepassword. [Author Typing] All right, so for this basically what's going to happen is they're going to send the current password and a new password in the body. So, first of all we want to find the user by the logged in users ID, which is of course is this, but we also want the password which by default is select false. So, we want to go ahead and do .select. And then in here, I want to do +password. All right, so we get the user and then let's go ahead and check current password, and make sure that's true. So, we'll say if... Now, remember we have... in our module we have that match password method, and it's a synchronous and it returns a promise so we want to say if not that, so in order to use await we need to just put in some parentheses. So, we'll say await match... I'm sorry user.matchPassword and then we'll pass in req.body.currentPassword. [Author Typing] So, if that fails then we want to return next [Author Typing] with an ErrorResponse and just say password is incorrect, it's going to be 401. Okay, if they get the password then we're just going to take the user object and set the password to the new password which is going to be in req.body.newPassword, okay? And then we want to save the user, so await user.save, and let's actually return a token, okay? Because if they change the password I just want the token to be sent back just like when they reset the password. So, sendTokenRresponse, and we're going to do user, 200 and res. [Author Typing] Okay, so let's try that. We're going to go create a new tab here and PUT URL, [Author Typing] V1, we're going to do /auth/updatepassword, [Author Typing] add the Json content type and then in the body, let's say you want to do route, [Author Typing] and we need the current [Author Typing] password, which for John Doe is 1 through 7, and then the newPassword [Author Typing] which I'm going to put back to 1 through 6. Now, we need to be logged in, so let's open up the login tab and send. Okay, so now we have the token and let's just choose authorization here and then bear token. And then we'll try and send that.... oh we didn't create the route. I seem to keep forgetting to do that. So, in our auth route let's bring in updatePassword and we'll put this right under updatedetails, it's going to be a PUT request, [Author Typing] updatePassword and protect, updatePassword. Okay, so let's just log in again get a token and send, and there we go. So, we get a token back and the password should now be 1 through 6. So, let's save this as update password, update user, [Author Typing] logged in user password and let's say send in the body [Author Typing] currentPassword and newPassword. Okay, so we'll save that and now let's make sure the password actually changed so instead of logging in with 1 through 7 with John Doe, let's do 1 through 6 or let's do 1 through 7 first and that should fail. Okay, so now we'll do 1 through 6 and that works, all right. Good, so now we're able to update our own information. So, in the next video what I want to do is the user's functionality for the admin. So, basically I just want to do a user's route, users controller, and basic crud operations only available to the admin. All right, and that should be pretty easy. And then after that we're going to move on to reviews.



UPDATE USER DETAILS 

All right, so now we want the user, the logged in user, to be able to update their name and email and also update their password, and these are going to be two separate routes. So, we are going to have a user's controller and users route and you could put this stuff in the user's controller, but I want that to be more for just the admin functionality to basically, crud functionality for users which only admins can do this is more for authentication, because it has to do with the current logged in user. At least that's how I like to see it if you want to set it up differently and put these routes in your user's route, you could do that but I'm going to use Auth. So, I'm going to go down and just copy.. the getMe, which is... where is it? Right here. [Author Typing] And actually we'll go right under it. [Author Typing] And this is to update... user details, and it's going to be a PUT request, [no audio] to auth/updatedetails, private and let's change the name here, updateDetails. Okay, so we're going to use findById and update but we don't want to just pass in request.body because then, if a password is sent or a route or any other user field that's in the module is sent it will actually update that. We don't want that, they should just be for the name and email. So, we're going to say const fieldsToUpdate is going to be the name, so req.body.name, email: request.body.email. All right, and then down here let's do findByIdAndUpdate, We'll pass in the ID, so this is the logged in user's id, and then fieldsToUpdate. All right, and then we'll pass in our new true and runValidators, we're going to set that to true as well, and then we'll just return we'll keep this. Okay, so let's save that. Let's add this to our route. So, we want to bring in from our controller updateDetails, I'm just going to copy this /me and change this to updatedetails, and we want this to be a PUT request. And it's going to keep the protect middleware and we're going to run updateDetails the method. So, let's go to Postman. And let's see... we'll create a new tab here, [Author Typing] it's going to be PUT [Author Typing] /auth/updatedetails and we're sending Json data so we need that. And let's send email, [Author Typing] John@gmail, [Author Typing] and then name, [Author Typing] let's do John Smith. All right, so we have to be logged in, so let's go to the Login tab and send that. So, the token gets stored and then let's choose authorization, bear token, okay, so that should be good, let's go ahead and try and send that. All right, good, so we get back a response with the user and we get John Smith. So, we can update that, we can also update the email if we want to do like John1 and send, you can see that that was updated, but I'm going to put it back to John, I'm also going to put it back to John Doe. [Author Typing] Okay, and let's just save this tab as Update User Details. And then in the description here we'll just say update logged in user name and email, okay? So, that's that. Now we want to do the update password. So, back in our controller. Let's copy the getMe function here again and we'll go right below the user details, and let's say update password. And this is also going to be a PUT request, [Author Typing] and it's going to be auth/updatepassword. [Author Typing] All right, so for this basically what's going to happen is they're going to send the current password and a new password in the body. So, first of all we want to find the user by the logged in users ID, which is of course is this, but we also want the password which by default is select false. So, we want to go ahead and do .select. And then in here, I want to do +password. All right, so we get the user and then let's go ahead and check current password, and make sure that's true. So, we'll say if... Now, remember we have... in our module we have that match password method, and it's a synchronous and it returns a promise so we want to say if not that, so in order to use await we need to just put in some parentheses. So, we'll say await match... I'm sorry user.matchPassword and then we'll pass in req.body.currentPassword. [Author Typing] So, if that fails then we want to return next [Author Typing] with an ErrorResponse and just say password is incorrect, it's going to be 401. Okay, if they get the password then we're just going to take the user object and set the password to the new password which is going to be in req.body.newPassword, okay? And then we want to save the user, so await user.save, and let's actually return a token, okay? Because if they change the password I just want the token to be sent back just like when they reset the password. So, sendTokenRresponse, and we're going to do user, 200 and res. [Author Typing] Okay, so let's try that. We're going to go create a new tab here and PUT URL, [Author Typing] V1, we're going to do /auth/updatepassword, [Author Typing] add the Json content type and then in the body, let's say you want to do route, [Author Typing] and we need the current [Author Typing] password, which for John Doe is 1 through 7, and then the newPassword [Author Typing] which I'm going to put back to 1 through 6. Now, we need to be logged in, so let's open up the login tab and send. Okay, so now we have the token and let's just choose authorization here and then bear token. And then we'll try and send that.... oh we didn't create the route. I seem to keep forgetting to do that. So, in our auth route let's bring in updatePassword and we'll put this right under updatedetails, it's going to be a PUT request, [Author Typing] updatePassword and protect, updatePassword. Okay, so let's just log in again get a token and send, and there we go. So, we get a token back and the password should now be 1 through 6. So, let's save this as update password, update user, [Author Typing] logged in user password and let's say send in the body [Author Typing] currentPassword and newPassword. Okay, so we'll save that and now let's make sure the password actually changed so instead of logging in with 1 through 7 with John Doe, let's do 1 through 6 or let's do 1 through 7 first and that should fail. Okay, so now we'll do 1 through 6 and that works, all right. Good, so now we're able to update our own information. So, in the next video what I want to do is the user's functionality for the admin. So, basically I just want to do a user's route, users controller, and basic crud operations only available to the admin. All right, and that should be pretty easy. And then after that we're going to move on to reviews.


ADMIN USERS CRUD 

All right, so now we want to create our users routes and controllers. And basically all the methods we're going to have are going to be admin based. So, to be able to get a list of users, get a single user, create a user update, delete, all that stuff is going to be all just for admins. So, let's start with creating the routes file. So, we'll create a users.js in the routes, and also in the controllers, we'll also create a users.js. So, in the controller, let's copy from any of these other controllers, the error response in the asyncHandler. Actually, let's copy from user, from auth, because we're going to need the user model as well. I'm just going to copy this stuff, paste that in, we don't need to send email. And then, let's just grab from the auth controller, we'll copy, [no audio] let's see, we'll just copy this register. [no audio] Okay. So, the first route is going to be to just get all users. So, this is going to be pretty simple, we're going to say get all users, and it's going to be a get request to/users. So, now we're following strict rest standards. And it's going to be, we'll say private, and let's say Private/Admin, okay? So, we're going to call this get users, and then we're going to use our advanced results, remember that middleware we created? So, this is one line of code, we'll just do res.status(200), and then .json, and we'll have access to res.advancedResults, because we're going to use that middleware. And I'm actually just going to create all the methods here, and then we'll add the routes. So, the next one is going to be to get a single user, so let's just copy this. So, let's say get single user, and it's going to be a get request to users/:id. And we'll just change the name to get user. And very simple, we're just going to const user=await user., and we're going to use by ID, and the id is going to be in the param, so req.param.id, and then we'll res.status(200). json success: true, and data is the user. So, to create a user, let's copy this. So, these are all very basic, but they're only going to be accessible to admins. Create user, it's going to be a post to just users. [Author Typing] Let's change this to create. So, to create a user, we're just going to set this to user.create, and we're going to pass in our req.body. And then we'll send back the user. But let's do it 201, since we're creating a resource. So, update user, I'm just going to copy this, [Author Typing] update user, that's going to be put to users/ and then the ID. And we're going to use findByIdAndUpdate, pass in the req.params.id to get the ID from the URL, pass in the req.body, and then let's set new true, and run validators to true. And then for the status, let's do 200, success true, and we're going to send back the updated user. And then the last thing we want is the delete. So, let's say delete user, which is going to be a delete request to that same route, change this. And then we're going to use here findByIdAndDelete. And we don't even have to save the user, so we don't have to put this into a variable. We're going to call and delete, and all we need to pass in here is the ID, so you can get rid of all this stuff just like that. And let's see, as far as what we want to respond with, we'll just say data empty object. So, now let's go into our router. So, users.js, and we need to first of all bring in express, actually let's just copy, [no audio] let's just copy the courses I guess, just to give us a starting point. [no audio] So, bring express, and then we need to bring in all those functions we just created, so we want get users, let's change this to users. We want get user [Author Typing] create user, update user, [Author Typing] and delete user. All right, so bringing those in, let's see, we're going to bring in [no audio] our user model. [Author Typing] And we're going to use advanced results, we want to bring that in. We also want our middleware, we should actually put this. Let's move this down [no audio] here, and we'll do that in courses as well. Just so the middleware is together, save that. See we do that in Bootcamps as well. All right, so back in our users routes, so we're bringing in protect, and authorize. [no audio] Let's see, we're going to [no audio] get rid of this, and this. So, all of our routes are going to either be / or /id. On /, we're going to have our get users. So, let's say on a get request to /, we're going to call get users, and we want to use our advanced results middleware, and our authorize admin. So, let's say authorize. [Author Typing] Actually, I'm going to show you a much easier way to do this. I am going to put the advanced middleware [Author Typing] so, I'm sorry, advanced results. [Author Typing] And remember, advanced results takes in a model, and then any populate that you want, but we don't need a populate here, so we're just pass in the model of user. Okay, now we want to use protect, and authorize admin for all of our routes, right? So, instead of putting it in here, we can actually just put it right above the router. So, for instance, we can say router.use, and then protect. So, what's going to happen is anything below this is going to use protect. So, we don't actually have to stick it in each one of these, anything below it will use this middleware. And we want to do the same with authorize. So, router.use, and let's set authorize, and it's all going to be admin, so just admin. And now any route we create below this, it will be protected, and you'll have to be an admin. So, we also want our post on this. Let's actually format this like that. And then we want .post, so when we make a post request to our users route, we're going to call the create user function. And then the rest are going to go on the ID. So, for instance the get request is going to call get user, it's going to get a single user, and a put request will do update user, and delete will do delete user. All right. So, let's save that. And now, let's try it out. So, we'll go to Postman and we're going to have a whole new folder here. [Author Typing] So, Add Folder and let's say Users. And in the description, we'll say... I will say, "CRUD functionality for users only available to admins." Okay. And we'll create... We'll open up a new tab here, and let's make a GET request to our URL/api/v1/users. So, if I go ahead and send that, we need to bring it into our server.js, this routes file. So, in server.js, right here where we have all of our routes, copy that down. It's going to be users. [Author Typing] And users, and then down here where we mount the routes, same thing. [Author Typing] Okay. So, now it should see those. What's this? [Author Typing] See Route.put() requires a callback function but got undefined. So, let's see what do we do here. So, put updateUser, looks like it has an issue with that for some reason. [no audio] That's why, there's no... I didn't put updateUser, so it's looking for something that's not there. So, let's make sure we change that and then that error goes away. Good. So now, let's try to send this and we get not authorized. So, now, I'm going to test this with a user that's not an admin. So, let's open up the Login User and let's login as John Doe. [no audio] Invalid credent-... Yeah, I changed this password to six. So, let me just save that. Okay. So, now we have the token. And now when we get a list of users, let's go to Authorization and use our Bearer Token and send, and we get User role publisher is not authorized to access this route. Okay. So, and it would do the same thing if it was a regular user. Now, as far as an admin, I don't think we have one in the database, because remember we have to change it manually. So, let's make... I have this account right here, admin@gmail. I'm actually going to edit this, changed it to an admin. Okay. So, now, let's go back to Login User and let's do admin@gmail, and let's login. So, now go to GET users and send, and now I get all the users, which is exactly what should happen. So, let's save this as Get All Users. We'll say Get all users and we'll just say, we'll just put (admin). And let's save this in the Users folder. So, now to get a single user, let's do this. Let's put an ID in here. So, we'll say slash and we'll grab one of these IDs, Barry Dickens. I don't know where I got that name from. So, slash that ID and send. And we get Barry Dickens. And remember we have to be an admin. So, let's save this, let's say, Get Single User. [Author Typing] get single user by id, has to be admin. All right. Let's create a user. So, make a PUT to just /users and let's see. We'll add our JSON Content Type. And then, in the body, let's go ahead and add a user. [Author Typing] So, I just add myself. Actually, I think I'm already in there. So, let's do like, I don't know, Nate Smith. [Author Typing] "email": [Author Typing] Now when I add a password, it should still get encrypted because we're still using our user model. Obviously, we have that piece of middleware in there, so this should get encrypted. [Author Typing] And we could set a role or we'll just leave user as the role. So, let's see if that works. Send. 404 not found. I need to make a POST request. [Author Typing] There we go, Nate Smith, and you can see that the password is hashed. Good. So, let's save this [Author Typing] Create User. [Author Typing] Add user to database (admin). And this is what's great about using the middleware for stuff like the password encryption is because we didn't have to deal with that in the actual controller method. The controller methods are very clean. It's just going to encrypt it automatically. So, now let's do an update. So, I'll just take this id for Nate Smith and let's change this to a PUT. [Author Typing] And throw his ID in there. And then let's change... [Author Typing] we'll do change the name to Nate Johnson. PUTS, okay, good. Everything looks good. And let's send and you can see, we get back Nate Johnson. So, we'll save that. [Author Typing] If you want to do better descriptions, that's fine as well, but I don't want to spend too much time on that. So, the last thing we want is a delete. So, let's delete Nate. So, we'll just say DELETE and we don't need anything in the body. We don't need our JSON Content Type and let's send, and now Nate's deleted. Okay. And just to let's save this first, and then we'll double check. [Author Typing] Okay. Now, if we get all users, we have 15, which is what we should have before we added Nate. So, now we have complete CRUD functionality for users, and it has to be an admin or none of these routes will work. It's all protected for admin users. Okay. So, I think that we're getting there, guys. In the next section, we're going to start to work on reviews. Because we haven't added that resource yet, we want to be able to write reviews for bootcamps. Only users can write reviews, and of course admins. And we want to be able to calculate the ratings from all the reviews, and put that into a field in bootcamps. So, we're going to do stuff like that in the next section.


REVIEW MODEL & GET REVIEWS 

All right. So, we're now ready to start on the reviews functionality or the reviews resource. So, first thing we do, usually when we add a new resource is create the model. So, that's what we're going to start with. We're going to create a 'New file' in models called Review.js, capital R. And let's just copy, we'll just copy the User or the Course, we'll copy the Course model here and just go from there. So, I'm going to get rid of everything under the Schema except for the export. Okay? And then we're going to change this to ReviewSchema and we're going to have a title, so we can leave this, let's say, Please add a... We'll say, Please add a title for the review. And, let's give this a max length. We'll say maxlength of 100. [Author typing] So, next we want, basically like the just the review itself, which I'm going to call text. So, we have a title and text. This will be string. It'll be required, so we'll say, Please add some text. Okay. So, next we're going to have a rating, [Author typing] and this is going to be the type Number, and it's going to be a one through 10. So, we're going to have a minimum of one, and a maximum of 10. It's going to be required. And let's say for the message, we'll say, Please add a rating between 1 and 10. Okay. So rating, let's see, so the Reviews are going to be associated with a bootcamp. They're also going to be associated with a User. I'm going to get rid of this tuition and minimumSkill and scholarshipAvailable. Get rid of all those will keep the createdAt which will be the default Date. And then here, we're just going to keep this as is because it's going to be associated with the bootcamp. So, we're using an ObjectID type here, referencing the Bootcamp model. Same thing here referencing the User model. And then we're going to export Review, and it's going to be the ReviewSchema. [Author typing] Okay. So, I'll save that. And now, let's create our route and controller files. So, we'll go ahead and create inside routes a new file called reviews.js. And in controllers, we'll create reviews.js. And just for now, just to get something in here, we'll just create a simple route. But let's grab from one of these other route files. I'm going to grab the ErrorResponse, the asyncHandler, and a model. Actually, we're going to need the Bootcamp model. So, I'm going to just copy all this from the courses controller and paste that in. And then, we'll just change this to Review because we're going to bring in the Review model. All right? And then, let's see for our first route, let's copy the getCourses and paste that in here. And this will be Get reviews. And basically, we're going to do the same thing we did with courses where we can get all of the courses. I'm sorry, all of the reviews, and we can get just the reviews for the bootcamp. So, say reviews here. We might as well just do this route because it's pretty much the same thing. We're going to see if there's a bootcampId in the URL. If there is, then we're going to create a variable here called reviews, were going to await and use the Review model, call find, and we're going to match the bootcampId, okay? Then we're going to return success true. We're going to return the courses. I'm sorry, the reviews length for the count and then the reviews for the data, and we're going to use their advancedResults again. So, this is really cool because any new resource we add to this application, we can simply just pop this in here. And of course, we have to add it as middleware within the route file. So, let's save this, and let's go to our routes. So, route/reviews, and let's bring an express. [Author Typing] Actually, you know what, let's just copy from the courses route file. I'm just going to grab all this and paste this in. So, we bring an express. We have one method in our controller right now called getReviews. So, let's change this to controllers/reviews. [Author Typing] And then, let's see, we're going to need our Review model. So, change this to Review. An we're going to bring in our router, we're going to keep this mergeParams true, because again, we're going to be able to go to /bootcamps /bootcampId/reviews. We're bringing in the advancedResults middleware because we're going to need that, we're going to need our auth middleware or protect and authorize. And then, let's see, we're going to have to just slash, that's actually going to be our getReviews. So, we're going to use the advancedResults middleware, we're even going to keep the same, when we need to change the model that's being passed in. But we're going to keep the same populate because we want to populate with the bootcamps name and description. And then we just want to change this to getReviews. All right, and I'm just going to get rid of this other stuff for now, we'll add that when the time comes. Okay? So, we'll save that and then we need to go to our server.js and just bring in the route file. So, copy this down and let's take this and change that to reviews and then we have to go down here, where we mount the routers and let's change this to reviews and this to reviews and save. All right. So, let's see what we're getting down here. Route.get () requires a callback function. Okay, so, I got object undefined. So, if we look in our Reviews route and we look at our get right here. So, we're passing in our advancedResults middleware and then getReviews, which should be coming from, did I not change the name? I didn't. And you guys probably saw that a while ago. So, getReviews and save, and that should clear up that error. Now, we should actually be able to get our reviews. So, I'm going to go back to Postman, and I'm going to create a new folder in our Collection here. So, let's say 'Add folder' and this is going to be Reviews and we'll just say, Manage course reviews, 'Create' and let's create a new tab here. Let's make a get request to our URL environment variable /api/v1/reviews. And this should get all of the reviews. So, if we go ahead and 'Send' that, obviously we don't have any but we get a successful response. Okay? So, I'm going to save this as Get All Reviews and we'll just say, Get all reviews from database we'll say, database and populates with bootcamp name and description. And let's save that in our Reviews folder. Okay, so we have that. Now, we want to be able to get the reviews from a single bootcamp. So, what I'm going to do is fetch a bootcamp id, so we'll grab this one here, and just save that and then we need to be able to go to /bootcamps /bootcampId/reviews. Okay, so that's the route we want to be able to hit which right now isn't working, we get a 404 because in our bootcamp routes, okay? Routes bootcamps, we need to do what we did with courses and create our reviewRouter here, [Author typing] which is going to come from our reviews routes. [Author typing] And then, let's see right here, copy that down. And we're going to anything that goes to bootcampId/reviews is basically going to be forwarded to the reviewRouter. Okay, so let's save that and let's see if that works now. So, we'll 'Send', and there we go. So, we get a successful response. Obviously, there's no data, but it should be working. So, I'm going to save this as get, I'll say, Get Reviews For Bootcamp. All right. We'll just say, Fetch the reviews for a specific, I know it's kind of redundant, but I just want to have a description for every route for when we do our documentation for specific bootcamp. All right, so save that to reviews. Good. So, what we'll do next is create a route and a controller method to actually create reviews.


GET SINGLE REVIEW & UPDATE SEEDER 

All right. So, I know in the end of the last video I said we were going to do the create functionality, but before we do that I want to be able to get a single review, and I also want to update our database seeder to include the reviews.json file and put that data in there so we can work with it. So, let's go to our controllers and go to reviews and I'm just going to copy this route or this function method. And let's see. This is going to get a single review, and the route is going to be reviews/:id. Now we can get rid of this second route here, and it's going to be public and we're going to call it getReview. And let's see. We're going to want to... I'm just going to get rid of everything in here, and we're going to create a variable called review. And we want to await on Review.findById. We're going to pass in here our req.params.id and we're going to actually populate here. I want to get the boot camp's name and description. So, let's pass an object with path, to boot camp and then we want to select the name and description. So, that will get that. Now let's check to make sure that the review exists. So say, if(!review), then let's return next, and let's say (new ErrorResponse. And the message will say, 'No review found with the id of' and then we'll just put in the . All right? And then as far as the status code, it's going to be a 404. And then under that, if everything goes okay, then we're going to res.status(200).json. And in here let's pass in our success true. And the data is going to be the single review. All right. So, save that, and let's go to our routes and reviews, and let's bring in getReview. And down here we're going to add in router.route. And we're talking about the route that has '/:id'. And we're talking about a get request, and that's what we want to call getReview. So, let's save that and we'll just use this here. So, we'll say get reviews. Actually we have no data. So, and if I were to do like /1, we should get a 404 and we get bootcamp. All right. So, let's see. Something is not right here. [no audio]. You know what's happening? This is probably something we should have fixed a while ago in our error handler. So, if we go to our middleware error.js, it's a cast error. So, it's saying boot camp not found. So, what we want to do here, is Resource not found. Because it might not be a boot camp. I should have did that a while ago. So, let's save that. [no audio] There we go. And the reason that, that is firing off, is because this is not a properly formatted object Id. If we had a properly formatted object Id, then it would throw our error response that we have in the controller. So for instance, if I get a boot camp Id which is a properly formatted Id, and I put that in here. Now we get that no review found with the id. However, we're getting a 500. That should be a 404. I put the 404 here. It should be within the parentheses. All right. So, if we try that again, now it's 404. So let's see. we're going to just go ahead and save this as get... [Author typing] Let's say, Get Single Review. [Author typing] Fetch a review from database by id and populate boot camp name and description. Okay, so save that. All right. So, now let's edit our database seeder. So, seeder.js, and we're going to just do what we did with the other resources. we need to bring in the model. So, let's take this and bring in Review. And then let's see down here, we're just going to just copy this down, and change users. And these keyboard shortcuts guys, I mean I'm just going to go right here hold shift and then the arrow and I can select users and then a Ctrl+D will select the next users match. And I'm just going to change that to reviews. Okay, just in case you don't know what I'm doing here. And then escape will give us our one cursor back. And then down here we just want to copy this down. We can do that with shift option down, will change that to Review. And we're going to create from reviews, data imported, and then when we delete data, we also want to delete the reviews. So, say Review.deleteMany. So, let's save that and then let's run it. So, I'm just going to stop the server and run, first of all seeder. I'm sorry, node seeder -d, and then we'll run node seeder -i [no audio] data imported. And if we want to check out our database, [no audio] now, you can see we have eight reviews in our reviews collection, along with all of our other stuff here. So, let's go to postman and let's go to GetallReviews. Oops, we have to run our server. [Author Typing] So, get all reviews and we get eight reviews and it has pagination because we used the advanced results middleware that we created. And we have an _id, we have a title, text, rating, the boot camp with the name and description and id, the user, and the createdAt. So that's a single boot camp. I'm sorry, all the reviews. Now if we want reviews for a single boot camp, let's grab an id. I believe they all have reviews. So, I'm going to grab this id right here for the bootcamp, and then go to Get Reviews for Bootcamp, and just throw that in here. And then send and we get success. We get "Count": 2. And in our data you can see we have two reviews for that boot camp. So, that's exactly what we want. I'm just going to save this. So, to get a single review, let's grab an id of a review and go to Get Single Review and then put that in here and send. And now we get an object with the information for that single review. So, we'll save that. All right, good. So, we're on the right track. In the next video we're going to make it so that we can actually create a review.


ADD REVIEW FOR BOOTCAMP 

All right. So now, we want to be able to create a review for our bootcamp. So, let's go back into our reviews controller. Oops, not in users, reviews. And, let's just copy our last routes. [Author Typing] Or not route but, method. And we'll change this to Add review. [Author Typing] So, this route is going to be POST. It's going to be a POST request. Now, we need the actual bootcamp that we're adding this for. So, we're going to set this to 'bootcamps/' and then we need the bootcampId. So, actually we'll just do this. So, 'bootcampId/reviews'. Okay so, that's the route we want to hit to be able to create a review and of course this is going to be Private. You have to be logged in. You also have to be a user. So, we're going to need to add the authorized middleware for this. So, let's change this to 'addReview'. [Author Typing] And let's just get rid of all these for now. Actually, we can keep the status. So, we need to... We've done this before. We need to add the ID, the bootcampId. That's in the URL to the data we're submitting. So, we're going to take the 'request.body' and then add on 'bootcamp' and set that to the 'req.params', which is from the URL. bootcampId, like that. We also need the user. So, we're going to set 'req.body.user'. And, we're just going to get the logged in user for 'req.user.id;'. Okay then, we'll go ahead and create a variable called 'bootcamp' and we'll await our 'Bootcamp.findById'. And we can pass in here 'req.params.bootcampId', okay. And then, we just want to check for the bootcamp, make sure that exists. Okay so, there's no bootcamp. Then, let's return next. [Author Typing] And we'll put in here. [Author Typing] Okay then, req.params.bootcampId. And that's going to be a 404. Okay so, we have our error message. And if it does exist then, we want to create our review. So, let's say const review. [no audio] Actually, you know what, we don't even... Let's put it in a variable so that we can respond with it. So, review = await, take our 'Review.create'. And, we're going to pass in here the req.body which will have all the body data that's submitted. In addition to that, it's going to have the bootcamp and the user. All right. And then, we'll just go ahead and have this same response. Actually, let's do it 201 since we're creating a resource. So, we'll 'Save' that and then let's go into the routes, reviews, and bring in, addReview. And then, as far as where we're going to add this, it's going to be on this route here, just slash. So, let's see, we have .get. So after that, let's do .post and it's going to be 'addReview' but we want to protect this. Okay so, only logged in users. Also, we want to add our authorize middleware. [Author Typing] And the only people that should be able to write a review are 'users' or 'admins'. Okay, not publishers. So, let's 'Save' that. Now, I also want to make it so that users can only write one review per one bootcamp. And we can actually do that really easily by adding an index. If we go to our model, if we go to... Where is it? Review... To our review model. We can just add an index by going right here and on the ReviewSchema, we can do .index and we can set in here we'll just add an object with bootcamp: 1. And then, user: 1. And then, just add seconds parameter of options and set unique: true, okay. So, it has to be unique. So, a user only be able to add a review for one, not for one bootcamp but, only one review per bootcamp. So, let's just say, // Prevent user from submitting more than one review per bootcamp. Okay so, let's try this stuff out. We're going to go to Postman. And, we'll just open up a 'New Tab' here. We're going to make a POST request to our }/api/v1/bootcamps. And then, let's see, we're going to need the bootcampId we want to add a review for. Actually you know what, let's create a new user for this. So, I'm going to go to my 'Authentication', 'Register User' and let's register user test@gmail as a... Actually, you know what, let's try it first with a publisher because it shouldn't work. And, I'm just going to call this user, test user. Because I believe... [Author Typing] Oops, what is going on? Capital T, Test User. All right. So, let's just register this user. And now, the token should be in our environment variables. So, back in this route here, let's choose a bootcamp. So, let's see. We go to get all bootcamps and 'Send' and we'll grab this one here which is Devcentral. So, grab Devcentral's ID. And then, we want to make a POST request to bootcamp/5d725a1b7b292f5f8ceff788/reviews. And let's see, as far as authorization, we want to use our Bearer Token. And in the 'Headers', we want to add our 'Preset' for JSON content. And then the body, let's go to 'raw'. [Author Typing] And let's see, we have what, a "title": "Nice Bootcamp". And we have "text": "I learned a lot". [Author Typing] And then a rating. So, we'll give the "rating": 8. And then, I think... I think, that's it. That's all we have to submit. So, let's go ahead and try it. Okay so, "User role publisher is not authorized to access this route." So, that's... It's perfect, that's what should been happen. Now, I'm going to just change from here, from Atlas or, not Atlas. What is this? Compass. I'm going to change that user we just created, which is our Test User. [Author Typing] Right here, I'm going to change the role to user instead of publisher. [Author Typing] All right. So, we'll go ahead and 'Save' or 'Update' that. And now, we'll try this again. 'Send' and now it works. So, we get back our response. And if I try to do this again, "Duplicate field value entered". And, the reason that's happening is because there's already a review with that user for this bootcamp, okay. And if we now go to... Let's see. Let's go to 'Get All Reviews'. We should see that new review. You can see "count": 9. And we get our nice bootcamp, cool. So, let's make sure we 'Save' this tab here. [Author Typing] Save this as Add Review For Bootcamp. [Author Typing] Say, Insert review for a specific bootcamp. [no audio] All right, good. So now, that we have that done, what I want to do next, before we do the update and the delete, I want to do the average ratings. So, we're going to basically do the same thing we did with the tuition costs for the courses. We want a field in our bootcamp that has the average review. Because that's something that's pretty important that we would want to display in our user interface. All right. So, we're going to get to that next.


AGGREGATE - CALCULATE AVERAGE RATING 

All right. So, in this video we want to calculate the average rating for each bootcamp, and actually put it in into the model. Okay. So, we're going to pretty much do the same thing we did with courses. So, if we take a look at our course and we go... Let's see down here, where we did the getAverageCost. We're going to do pretty much this same thing only with the rating. So, I think we can just go ahead and copy most of these. So, we'll get the statics method we created here, and then below that the middleware, where we called it. So, we'll copy that, and then go to our review model here... [Author Browsing] and let's put this right in here. And we're just going to change up some stuff here. So, say Static method to get avg rating and save. So, we want this to obviously run on the ReviewSchema... [Author Typing] And we're going to call this getAverageRating. It's going to get passed in the bootcampId, and then we'll do the same thing. We'll just create this object. We're going to match the bootcampId that can stay the same Id as bootcamp. Now, the field that we're dealing with here is averageRating. That's where we're putting this into. And we want to look at from the review model, we want to look at the $rating. Okay, that's what we're actually averaging. We're calling the $ave operator on that. All right. So, then down here, we're going to go ahead, and basically update the database and add that as a field. So, we're dealing with the Bootcamp model because that's where this average rating is going to go, and then findByIdAndUpdate, that's good. averageCost is going to be averageRating. And then we can get rid of this ceil method, this math right here and just to... [Author Typing] averageRating. It should work. All right. And then down here, we want to change this... [Author Typing] to ReviewSchema. And on save, we're going to call this.constructor.getAverageRating. Okay. We're going to do the same thing here... [Author Typing] and change this to ReviewSchema. All right. So, we'll save that. [Author Typing] Now, to try this out... [Author Browsing] Let's see 'cause we already have stuff in the database. So... [Author Browsing] You know what I'll do, let's just create a whole new bootcamp and a whole new reviews. So, I'll just delete everything in the database just for now. That's why I like this seeder because it's so easy to just clear everything out and put it back. So, I'm going to just clear everything out, and then run our server. Okay. And then let's go register a user. So, that's not what we want. 'Authentication' and 'Register User'. We have quite a few routes now and we'll just register John Doe. But we want him... Actually, we need to create a bootcamp. So, let's make John Doe the publisher. I'll register him, and then let's do, I don't know, "name": "Jack Smith", we'll say "email": "jack@gmail.com", and Jack will be a "role": "user". Actually, we'll do two users because I want to add two reviews, so we can see the average. So, we have Jack Smith we'll go ahead and register him as a user and let's do "name": "Mary Smith",... [Author Typing] As a "role": "user" as well. Okay. So, we have three users. Let's 'Login User' as John Doe, who's a publisher and we're logged in, so now we can 'Create New Bootcamp'. This is kind of testing out our API as well. So, we'll create the ModernTech Bootcamp with John Doe, which works. And now let's 'Login User'... [Author Typing] As Mary, who's a user and now let's create a review. Okay. So, let's get the Id for that bootcamp we just created. So, I'll get all bootcamps and just grab this Id here. Go to our Reviews. Go to 'Add Review For Bootcamp' and just replace the Id here, the bootcampId, and for body, we'll go ahead and just do an 8, and 'Send'. Okay, good. So, that was added. Now, to add another review, we need to be logged in as a different user. So, let's go back to our login tab and let's login as Jack, who's our other user. Okay. So, now we're login as Jack and I'm going to add a review here. Let's do a 10. [Author Typing] I'll just say, "Great..." I don't know, "title": "Great job". Doesn't really matter. And then 'Send'. So, now we should have two reviews on that bootcamp. We should also have the average rating on the bootcamp. So, now let's go to get all bootcamps and let's 'Send', and so let's check it out right here, "averageRating": 9,. So, we have a 10 and an 8, and it averaged it to the 9. Awesome. So, that seems to be working. And if we want to just, I don't know, I guess we'll test it one more time. We'll create another user. [Author Typing] Let's say "role": "user". Let's do just "email": "brad@gmail.com",. I'm going to delete this data anyway. So, we'll go ahead and register. We're logged in as brad@gmail.com, so let's add another review. Excuse me. And let's do a "rating": 6, and 'Send'. And now let's go back to get all bootcamps and see what we get for average, and now it's 8. All right. So, it's calculating that average as they get added. All right. And it should do the same thing when we delete a review, which should reaverage it. All right, good. So, now that we've done that let's go ahead, and actually I'll just leave this data in here just so we can do the next video, which is going to be the update. So basically, we want all of those users to be able to update their reviews.


UPDATE AND DELETE REVIEWS

All right. So we have two more routes to create for reviews; that's Update and Delete. So let's go into our controller. And I'm going to go down to the bottom here and just copy this last one we did which was add review. [Author Typing] And space that in and change this to Update. And this is going to be a PUT request since it's an update. Now, we don't need the bootcampId for this. We just simply need to go to reviews, and then the Id of the review/:id. Okay. And I'll change the name here to updateReview. [Author Typing] So first thing we'll do here is get the 'find the review by its Id'. So we can get rid of this stuff here. And let's see. We'll just change this to review, I'II change this to review and we're going to wait review.findByid. And we want to make sure we parse in req.params.id, and then we'll check for the review. [Author Typing] And if that doesn't exist, then let's say 'No review with the id of, and then make sure we change this to just id, not bootcamp.id. Now we need to do some permissions check here, we need to make sure that the review belongs to the user unless it's an admin,. and admin can edit anything on the site or in the API. So let's say if just put a comment here. And I'll say, Make sure review belongs to user or user is an admin. And we can do that by saying if(review.user) and we want to check the user. Now remember this is going to be an object Id. We want to change this to a string so that we can do a comparison. I want to see if that's not equal to the logged in user's Id which we can get with req.user.id, and it's not an admin. So and req.user.role! == 'admin'. Okay? If that is the case then we're going to return a response. Let's grab this and we're going to say, [no audio] 'Not authorized to update review'. Or maybe we should just keep it. Well, no, I guess that's fine. If you guys want to change the messaging you can. It's going to be a 401 since it's not authorized. And then down here we want to find by Id an update. So let's say, did I use await? Yeah I did up there. Okay. So we're going to say 'await' and then change this, create right here to FindByIdAndUpdate, which will take in the Id, so req.params.id and req.body is what we're parsing in here. And then the options we're going to have new: true. Because you want to return the updated review and then runValidators. [Author Typing] Why isn't that popping up? Usually it pops up. new: true, runValidators : true. [Author Typing] Okay. So that should be right. And then for the response we'll do (200) and success : true. We'll parse in the review as the data. So let's save that. It looks like we have an error. [Author Typing] Identifier 'review' has already been declared. Okay? So already declared, we declared it up here. So we'll simply change that to let and then just go like that. [Author Typing] Okay. So let's add this as a route. So we'll go to routes, reviews.js, and let's bring in updateReview and let's see where we want to add this. So updateReview, it's going to be on the ID right here. So let's go to the end and just add a put. Okay? So if it's a put request, to /id, then we want to call updateReview. But we also want to add our middleware. So let's add protect and also authorize. [Author Typing] Okay, so authorize has to be a user or in admin. Okay. So save that and let's give it a shot. So we'll go to, let's go to Get Single Review, and we'll change this to a put request. It's going to be review/ and then the id. I just need to get an id here. So let's see this one. [no audio] Great job. I learned a lot. Six, I think this was mine, I think this is brad@gmail. But let's try with a different user just to make sure that that works. So let's just grab the Id of this review, [Author Typing] and put that in here. For headers we need the JSON content type, we need for authorization, a bearer token, so whoever is logged in. And in the body, [Author Typing] let's say, will change the title... I don't know 'Had Fun'. And we'll change the rating. We'll just change the title. That's fine. All right. But I want to do this as a user that doesn't own the bootcamp first. So let's log in. I keep going to the users, go to authentication and then log in. And your users might be different. So I mean, put whatever user in here you want. I'm going to use john@gmail. No John is the publisher. So I think who else do we have, Mary as a user. So I'm logged in as Mary and I'm going to go back here. Where is it? Right here to the put request, and try to send that. And we get, "Not authorized to update review", which is perfect. Okay. So now let's login as Brad, which is the user I believe owns the review. [no audio] Okay. So I'll log in here and then let's send. Params is not defined. Okay? So you were getting here, Params is not defined. [Author Typing] Right here, fineByIdAndUpdate, I just, I put a comma. There we go. So that should work. Let's try it. Send, and there we go. So we get title back, 'Had Fun'. So we're able to update our bootcamp. I'm sorry, our review. So I'm going to save this as Update Review. I'll just say, Update review in database. Okay. So now we want to do the Delete. So we'll go and close this up. [Author Typing] And we'll go back into our controller. And let's just copy the Update Review, [Author Typing] paste that in, and we'll change this to Delete review. And this is going to be a Delete request. To the same route. It's going to have the Id. Let's call this Delete review, and first thing we want to do is the same thing. We just want to get the review. We can use const here because we're not going to reuse this. And then we're going to check to see if it exists just like we did. And then we're also going to check to make sure it belongs to the user, so that can stay the same. And then we just want to remove it. So we don't need to do all this. We simply need to call await, and then on the review we can call remove. And then down here as far as the data we'll just return an empty object. All right. So let's save that and bring it into our routes. [Author Typing] deleteReview and it's going to be on the Id. We're going to add a .delete. And let's just grab this. [Author Typing] Okay? And then we'll just change this to deleteReview and we'll save that. All right? So let's go back, let's make sure everything's good down here. Okay? And then let's try to make a delete. So I'm going to say Update Review, and we'll change this to a delete. And we're already logged in as the user for this review. We don't need any party. Get rid of that. We don't need this headers value. Let's just go ahead and send the delete. And then we go, we get "success" : true. So now if I go to Get All Reviews, actually before I do that, let's save this. [Author Typing] Okay. Save that. And then if we go to Get All Reviews, we should only have I think two. So we get count, two. Okay. So we have full tried functionality on our Reviews. We have all of our permissions, it calculates the rating. In fact that should have changed. So the rating should now, since we have a 10 and eight, the ratings should be a nine. So let's let's actually go to Bootcamps, and Get All Bootcamps, and check out the average rating. We only have one Bootcamp, and it's a nine. Okay. So it ran on the remove as well. Okay. So I think that we're good here. Now, I'm just going to reseed the database. So just go ahead and run node seeder -d, and then node seeder -i, [Author Typing] and then run our server, and now we should have everything. So if I go to Get All Reviews, we have all that data. All right, cool. So we're pretty much done as far as functionality, as far as routes and all that stuff. I think that we have a pretty decent API here, 31 different routes to do different things. In the next section, what I want to do is make this API a little more secure and production ready. So we're going to add a few more packages and just protect ourselves against certain things, like NoSQL Injections, things like that. And then we'll move on to actually deploying our API. All right. So I'll see you in the next video.



LOGOUT TO CLEAR TOKEN COOKIE

All right. So we're going to start to get into security and add a couple packages to make our API more secure. But before we do that I want to take care of the cookie situation because if you remember, when we log in, we get down here a cookie called token with the value in it. Now we're not currently doing anything with this if I go to our off middleware, so right here you can see that this is commented out. Basically, what's going on here is we're checking the headers for the token, and if it's in there we're storing it in here and then we're moving on to verify it and so on. And we're just commenting out the cookies part of it. So, what I'm going to do is uncomment this and save it, and what will happen I'll show you real quick. If we go and log in it gets the cookie gets put in here, so it's in the client and it's going to get sent with every request now. So, if I go to a protected route like Get Logged In User and I take the bearer token out of the header, so I'll say No auth and I send its still going to work because now it's using the cookie. It wasn't found in the header so this was not true, but it looked in cookies and it wasn't there, so the token got set by that. Okay, so I mean it's really up to you if you want to use cookies or not, or if you want to use the header or not whatever but you have both options. But what I would like to do is have a log out so that we can actually clear this up. All right and just to show you if I log in as someone else, I don't think I have a Brown in there let's do like "Mary" and send, and then go to the Get Logged In User and send you can see now I get "Mary Williams" because it's not getting sent in the header it's looking at the cookie. So, let's create a log out route so I'm going to go into the controllers off and we have our login here, and I'm going to go right under it and just copy this, you getMe and paste that in. And let's say Log user out / clear cookie, and this will go to log out and we'll just make this a GET request, private, call this logout. [Author Typing] Okay? And then let's see we can get rid of this, and then we're not sending any data back so we can get rid of that, we'll just put an empty object there. So, in here, what we want to do is take that cookie and basically what I'm going to choose to do is just set it to none. So, we'll say res.cookie which we have access to because of the cookie parser middleware . Set token to none, and then what we'll do is set to expire in 10 seconds so it will expire really quickly. So, say expires: new Date (Date now() + 10* 1000) Okay, and then let's set httpOnly to true. Okay? So, if we save this and now we go back here, so we're logged in as Mary Williams right now. And then let's open up a new tab and make GET requests to our URL/api/v1/auth/logout and send, we need to add the route, I always forget to do that. So, let's go to our routes auth.js and we'll bring in log out, and then down here let's just copy the log in down, set that to logout. To set this to logout and set this to get, okay? And then let's go back here and send, and now we get a 200 response. Now let's go back to this, Get Logged In User and see what we get. So, we get not authorized to access this route. Should be not authorized, I guess let's change that because it doesn't really make sense. So, in our middleware, I'm just going to add a d right here and right here. And its good. All right. So, now if I log in as someone else, if I login as John and send that's going to get put in the cookie and then if I go to this route here to get the user, here we go. And if I log out, go back here, it's not going to work. Okay? So, let's just make sure we save this logout route, [Author Typing] so we'll say clear token cookie. And we want to save this to authentication, here we go. Okay? You can see this is set to none. And I set it to 10 minutes actually, but you can set it to whatever you want to expire. All right. So, I just wanted to handle that before we moved on. If you don't want to use cookies and you want to use just the header authentication, you can just again comment out that part in the auth middleware which I think I'm going to do just because I want to have to send the token in the header, but it's completely up to you on how you want to structure API. So, I'm just going to put a comment here though that says set token from cookie, and then here set token from Bearer token in header. And then I'll just comment this part out right here. [Author Typing] Actually, we want to keep this. [Author Typing] All right. So, that should just bring us back to how it was before, so if I go back and I login as John Doe we get our token, and if I go to Get Logged In User and I don't have my bearer token in the headers it's not going to work, okay? Because we're not we're not checking the cookie for the token. So, hopefully that makes sense. If I choose Bearer Token and it's in the header then it works. All right. So, in the next vide, we're going to move on to some security stuff. We have some vulnerabilities right now, such as no SQL injections and cross site scripting, so we're going to get into that next.


Prevent NoSQL Injection & Sanitize Data

All right guys, so we're getting there. We have all of our functionality done. So, if you look at the bootcamps, the courses, the reviews, uses, and authentication, all this stuff is done. All this functionality is done, so now we're going to move on to security. We already have our passwords, and reset tokens encrypted, so that's done. So, next is prevent NoSQL injections. We want to basically sanitize our data, and I just want to show you this article here. So, this is a really cool article. Put this in the links markdown file about SQL, and NoSQL injection with node, and MongoDB. And they give you an example here of basically hacking a node MongoDB express application, by putting in a user name using an operator, a NoSQL operator of greater than nothing. So, this will actually match the basically, the first user name that's found. And then password as well, although password won't work with us, because our passwords are encrypted. So, it goes through be cryptine does the match. However, if someone is able to guess a password that is on our server, or in our API, in the database, they don't need to know the user name, and I'm going to give you an example of that. So, if we go to our login route, and in the body, let's say someone isn't too bright, and they actually use this as a password, or maybe even the word password, or maybe it's an older person that doesn't really know any better. What someone could do is for the email, they don't even have to know it. They could simply pass in here the greater than operator, and set it to nothing. And now if I send, we get a token back. I didn't even have to know the email, I just had to guess a password in the database. So, that's obviously a big vulnerability, it's very unsafe. If I go to get logged in user, and send, you can see that it's actually the admin account, because that's the first one that was, that was found with that password. So, let's make it so that this can't happen. And there's a few options, actually there's a lot of options. As far as packages, we have mongo sanitize which you could use, you could bring it into your off controller, and then in the login, you could wrap the request dot body dot email, because that's where that data comes in, in this sanitized function. Okay, you could do that, but you would have to do that manually for everything you wanted to sanitize. There's another package called Express Mongoose Sanitize, where we can just bring it in, and add it as middleware, and it will sanitize everything, and it shouldn't let that happen. So, that's what we're going to do. Let's go ahead, and just grab this line here, and then we're going to install this. So, I'm going to stop the server, and NPM install express mongoose, mongoose-sanitize. [Author Typing] Why isn't that working? [Author Typing] Not Mongoose, Mongo, express-Mongo sanitize. [Author Typing] All right. So, then we'll run our server again, and now all we have to do to make this work is going to server JS, our entry point, and then we're going to paste this in here. Let's say const paste that in, and then just add it down here as middleware. Let's say, sanitize data app.use, mongoSanitize. And now let's go back, and try the same thing again, and see what happens. So, now we don't get our token, we get a 404, and we get resource not found with the ID of object object. Now this, we've changed this before, but it was boot camp not found no matter what resource, so we changed it to resource. But now we, this doesn't really make sense either. So, I'm just going to change that message to just resource not found. So, in our error.js middleware right here, we have this message. We're just going to say, 'Resource not found.' So, just kind of dummy it down, dumb it down a little bit. And now if we send, we just get resource not found, and this no longer works, because we have that package installed, and set up. All right, so now that we've done that, in the next video, let's see what we have for our next step in security. We want to add some specific security headers, and we're going to do that using helmet. We also want to prevent cross site scripting. We might do that in the same video, or in a different video. But that's what we're going to work on next.

XSS Protection & Security Headers

All right guys, so, now we want to add some special security headers, as well as prevent cross site scripting. So, the first package we're going to use is Helmet, which is pretty popular and very, very easy to implement. We just bring it in, and initialise the middleware. And what it does is, it adds a bunch of header values that can help make our API, or application more secure and this is a list of them and what is enabled by default. So, for instance, you have the DNS Prefetch Control and you can read all about what these are. So, the attack, when you visit a URL in your browser, the domain looks up the or DNS looks up the IP by the domain. Browsers can start the DNS requests before the user even clicks a link or loads resource from somewhere. This improves performance, blah blah blah. And then what this header does, is it tells the browser whether they should do DNS-prefetching. So, turning it on may not work on our browsers might not be supported, but it's just an extra precaution. And if you want to read more about this specific header or any of these, you can hit have XSS filter which adds some cross site scripting protection, but we still need more and I'll show you another package we can use for that. But these will add some extra headers. So, let's go ahead and first of all install this. So, we'll say npn install helmet [Author Typing] and then run our server. [Author Typing] And all we have to do is bring it in. So, just go ahead and let's see you just bring that down and change this to a helmet, [Author Typing] and then we just need to initialize it. So, let's go down here, well say Set security headers and app.use [Author Typing] helmet, now let's go back, let's go to Postman. And let's just, I don't know, we'll just get all bootcamps. So, now if you check out headers, we have a bunch of new stuff here, this XSS-Protection, our DNS-Prefetch-Control. So, now these headers are being added, which make our api a little more secure, we have this Content-Type-Options nosniff. So, it just adds a little bit more security and it's two lines of code. We bring it in and we enable and that's it. So, really cool package to use. The next one that I'm going to use is called express, not express XSS clean. [Author Typing] So, this is to prevent cross site scripting that's on it, or is it right here. So, middleware used to sanitize input. So, this is very simple as well. We just pretty much need to bring it in, and enable the middleware. They're using restify here which is something we're not using, we're using Express, but same idea. So, I just want to give you an example of what can happen here, without doing this. So, we're logged in. Let's see, let's log in as the publisher account. So, I'm going to go to Login User, because I want to be able to create a bootcamp. So, I'm going to just login as publisher. [Author Typing] And then go to Create New Bootcamp, and in here in the name, I'm going to go ahead and put in a script tag, and just say like alert(1). This could be some harmful JavaScript code, and then I'm going to send and if we look it down here in the name, we can see that the script tag is there. So, if this is embedded on the page, it's going to be embedded in our html. Now, there might be some extra steps that will prevent this from happening. But we don't even want the possibility of this happening, of scripts or any html tags being able to be put in here. So, let's see how let's update this and get rid of that. So, I'm going to go to, let's grab the id [no audio] and let's say, we go to Delete. And let's delete that bootcamp [no audio] because I want to install the package and then show you that again. So, let's go to VS Code and just say npm install xss-clean. [no audio] And then run our server and let's bring it into our server.js. So, I'm just going to go right under helmet just copy that down. We're going to bring in from xss-clean, and call this xss. And then we just need to enable it down here [Author Typing] to prevent XSS scripting attacks. So, app.use and then passing xss() and that's it. So, now let's do the same thing we just did. So, I deleted this bootcamp, so I'm going to re add it with the script tags, and let's see what we get down here as a response. Check out the script tags. So, at the beginning of the bracket has this & lt; So, the beginning bracket has this & lt; Okay, same thing with the ending one. So, now we won't have this script tag in our database which of course we don't want. So, that's what how that package works. I'm just going to grab this id and delete the bootcamp. [Author Typing] Okay, now we're preventing NoSQL injections, were sanitizing our data, were preventing cross site scripting attacks, were adding security headers. In the next video, what I want to do is add in a rate limit. I don't want people to be able to make a 1000 requests per minute, or whatever we want to set some kind of limit. That's fair for our api, all right. So we'll do that in the next video.


Rate Limiting, HPP & CORS

All right guys. So, in this video we're going to implement a rate-limit and we're also going to implement protection against something called http param pollution. And we have two packages for that, the first is Express Rate Limit. So, basically we can go down here, we can limit request to however many we want within a certain amount of time. So, here they're limiting it to 100 requests per 15 minutes. I'm going to do 100 requests per 10 minutes, and I mean you can go deeper and you can limit it to certain routes and stuff like that. Like you might want to limit... Maybe you just want to limit the password reset route or something like that. But I'm just going to go ahead and do an overall 10 or 100 within 10 minutes. Okay, and then this hpp, this is middleware to protect against HTTP Parameter Pollution attacks and you can read more about that down here. So, basically it says right here Express populates HTTP request parameters with the same name in an array. So, something like this. And then, attackers can intentionally pollute request parameters to exploit this mechanism. And down here gives you a little more information, but it's very simple to prevent this. Just like the rest of the packages we've used, we just bring it in and then we add the middleware and it takes care of it for us. All right so let's go and install both of these. I'm going to npm install express- rate- limit and also hpp [Author Typing] Okay [Author Typing] And then let's bring those in. So, we'll go up here, so bring in express-rate-limit [Author Typing] Okay, and we'll just call this rateLimit and then this one [Author Typing] hpp. Okay, so let's put this [Author Hamming] just go down here and let's say // Rate limiting. [Author Typing] So we'll say const limiter and this is the same code that's on the get up page. So, we're just going to set this to rateLimit(); and then in here passing an object with windowMs: and we can set that to let's do 10 minutes which is going to be 10*60*1000, [Author Typing] and I would just say 10 minutes. All right and then the max requests... Now I'm just going to put one just to test it out, ultimately it's going to be 100. But I just want to test it out with one. Okay, and then we just need to apply this here, so (limiter); [Author Typing] Okay, and then let's also do our hpp so let's say // prevent http param pollution. [Author Typing] All right so I think that should do it, let's save this actually just put that there. All right so now I'm going to go and make a request to get all bootcamps. Okay, so I made one request, let's make another one from this IP, too many requests please try again later. Okay, so that's what we're going to get and then we get a 429 response our Status code. So let's change this to 100, and now we should be able to make 100 requests per 10 minutes. And you can customize the error message and stuff like that if you really want to get into it. But I just want some basic protection so I'm not going to do anything like that. All right now I guess in this video we can add our cors functionality as well. So, if we were to make a request for... Now we're using Postman so we're able to do this, but if we had another domain that we were using and we had this API on a different domain, we would get a Cross-Origin error in Chrome. And we want to prevent that, we want other domains to be able to connect to our API, it's a public API at least that's what I'm making it. If you don't want it to be then you don't need to use cors. But let's say cors node.Js github, I just want to github page for this. [no audio] Okay, so this is pretty simple, I mean there's more advanced usage. But I want to just say the whole API is public so we can just install cors and then we should be able to just enable it just like we've done with this other stuff. And if you want to look more in depth down here different options and stuff like that, you can do that. But I'm just going to go ahead and install it. npm install cors [Author Typing] Okay, and then we'll just bring it in. [Author Typing] Okay, and then go down here. Say // Enable CORS, and we just need to do app.use(cors ()); [Author Typing] All right so now once we upload to a domain and then if we create a front end application that's on a different domain, we'll be able to communicate with our API. All right So, I mean these are all very easy packages to implement. I mean we didn't even really write any code, we just simply used the middleware, we use the predefined middleware. So, definitely some tools that you want to use with your node.Js apps and API is just to protect yourself against certain things. So, our API is pretty much done just make sure that this file is saved and what I would like to do next, is start to think about documentation. Okay, we have all of these different routes, but for someone to be able to use our API, because in this case is a public API we need routes, I'm sorry not routes. We need documentation that explains each route and what it does shows what is supposed to be sent with it and stuff like that. And Postman has a built in utility to do that, so we're going to do that and then we're actually going to use something called DocGen to create html files from that documentation that we can actually add to the index page of our API. Okay, so if we upload our API to Devcamper.io. If they go to the homepage of Devcamper.io, we want that documentation to show. So we're going to take some steps in order to be able to do that.


Documentation With Postman & Docgen

Okay so now we're going to create our Documentation. Now we can do this with Postman, we can create documentation. But I want to take it a step further and create HTML files with our documentation that we can just put on the index of our API, whatever domain we're using. So we can do that with the utility called DocGen. And I'll put the link in the link's Markdown file. So what I'd like to do is, and you can see down here what it creates, and it will look something like this. So we'll have all of our resources and then all of our routes and we get this nice layout with the routes, the method, the data that we need to send and all that stuff. And what I'd like to do is have it all right on our index page. So if we go to http://localhost:5000 or wherever our API is I want that to display here because right now it just says cannot get slash. Of course we can use our API in the browser like you can say api/v1/bootcamps and it works. It gets our data. But for the route, I want to display our documentation. Okay. So first thing we want to do is go to Postman and we can create, we can publish docs right here but before we do that, I just want to go to our environments. Let's see, let's click the settings right here, the cog, and we have our devcamper environment which has localhost:5000 as the the URL. And that's fine if you want to keep that as your URL that's okay. But I'm going to be actually deploying this to devcamper.io. Obviously if you're going to go through deployment you're going to have a different domain, so you probably want to put that. So I'm going to go ahead and just click on, where is it, Duplicate Environment. And then let's edit this, and let's call this devcamper, I'll just say devcamper prod for production. And we can actually, we don't need this token here, let's just get rid of that. And then here for the domain we're going to go ahead and change this, or I'm going to change it to devcamper.io, and you can change it to whatever domain you're going to deploy to. [Author Typing] And that should be good. Let's update. All right. So now we should have two environments: our devcamper and devcamper prod. And now I'm going to right-click here and say Publish Docs. And then it's going to open up a tab in the browser. We're going to choose current for the version, and then for the environment, I'm going to choose devcamper prod. This is available to Pro users. All right. So down here we just have some color options and stuff. I'm just going to leave all the defaults for this and then publish collection. All right. So what this does is it published our documentation at this URL. So, I'm going to just open this in a new tab and there we go. So we have some documentation where we have our bootcamps. Okay? We have all the different routes. You can see right here, Get All Bootcamps, and I used the devcamper environment or the production environment. So we have the actual domain here. So fetch all bootcamps. This is going to be the description that you put, and then over here it has an example request using curl. Okay. So I can actually grab this right here. Well, it's not going to work because it's dev camper which we haven't deployed yet, but we'll go ahead and just try it with local host, just to show you that we can use curl here. So if I change the domain to localhost port 5000 we get all our data. All right. So it has an example of making the request, here is the Get Single Bootcamp. This was to add a new bootcamp and it actually shows all the fields. Okay. So this is actually really cool but oops! What happened? What did I do? I'm going to close that. But it's not hosted, it's a separate website. So we could push to a GitHub repository and have this link in there for people to see. But what I'd like to do is have this stuff on the actual domain. If we go to devcamper.io or whatever the domain is. So we're going to use the tool called DocGen for that. Now we need to export from Postman, go over here and say export. And we want to export this as JSON. We're going to say this right here, Collection v2.1 (recommended) and export. And then we'll save it just as, let's save it as dc.postman_collection.json. I'm just going to save that to my desktop. Okay. So now that's saved. And that's what we need to basically plug into DocGen to generate the HTML. So now let's go back to the docgen GitHub here. And it's a little different if you're on Windows. With Mac, we can actually install with Homebrew, which is what I'm going to do. But if you're on Windows, you want to download the binary. Okay? And then once you download the binary, let me just open up a terminal here to show you what to do. So you want to go into the folder where the docgen binary is, and then just do a ./docgen like that, and then build -i, and then the JSON file, which I called, what do I call it? dc.postman_collection.json and then the output is going to be index.html. Okay. So the input is the JSON file, output is the HTML. That's what you want to do on Windows. Since we're on Mac, we want to install docgen with Homebrew, because if I run that, it's not going to do anything. So let's grab this right here and paste that in. [Author Typing] And if you don't have Homebrew, just go to, [Author Typing] I think it's brew.sh, and just grab this command, put it in your terminal, run it and you'll have Homebrew. Okay? And Homebrew is just a package manager for Mac. All right. So now that that's done. I'm going to clear this up, and we're going to run brew install docgen. [no audio] And then we can just run that same build command, that I just showed you that you would run with the Windows binary. Okay. So let's clear this up. And where am I? So I'm in my home, let's go to... I'm going to go to my desktop because that's where my JSON file is. So you can see the dc.postman. So from here I'm going to run docgen. And let's say build, input is going to be dc.postman_collection.json, and the output is going to be index.html. So let's try to run that. Documentation successfully generated. Okay. So now if I look at my desktop... [no audio] Let's see. So we should have right here index.html. And there we go. We have all of our documentation. So we have our description in here. And a put request, so it shows us what we need to send in the body. An example of what we can send to log in, register, reset password, and it shows exactly what to send. So this is really, really cool. And we can go to different resources. All the user stuff is down here, and reviews, courses, all the stuff. So what I like to do is have this page right here, show on the index of our API. So what we can do is take this HTML file and put it into our public folder. So I'm going to just grab this, let's just copy this, and then go into our project, and then go into public, and I'm going to just paste this right in here. Okay. And then if we go back to the browser and we go to localhost:5000 and reload, there we go. Now I believe we just open up the console here. So there are some icons that aren't being loaded. And I can show you that if we go into that index.html... Let me just close this stuff up. So if we go into public index.html there is... Where is it? [no audio] You just search here for halflings. Yeah, right here. So it's looking in ../fonts/glyphicons-halflings-regular.eot, and then this halflings-regular.woff2 which don't exist. So what I did is I just searched for this. So I'm going to just copy this right here [Author Typing] and then I'll just search Google, and it's just part of the Bootstrap template here. [no audio] Let's see is this idea. So we have inside this fonts folder, we have the WOFF and the EOT. So we just want to download those two files. Actually just I guess we'll download each one. So grab this. Okay, so that got downloaded. And then I'm going to grab the WOOF or WOFF. We are going to download that as well. And let's show and find her, and I'm going to grab both of these. And we're going to copy that, and put that inside the public folder. Next to our index.html we're going to have fonts and paste those two items in there. So now if we go back to localhost:5000 and I reload... Looks like we need this WOFF2 as well, which is right here. So we'll just download this one. Okay? And then we'll grab that and put that right in there as well. Okay. And now if we go back and reload, now, we don't have those warnings and we get all the icons we need. Awesome. Okay so we're pretty much ready to deploy. We have our API complete, we have our documentation, we have it displayed on the route or the index of the domain that we're hosting, the API i which right now is just our local host. So in the next section, we're going to move on to actually deploying this to a digital ocean droplet, adding an SSL, we're we're going to put it behind an engine X reverse proxy. So I really want this to be like a production type API that we would be building. Okay, so we'll do that next.

Digital Ocean Droplet & Server Log In

All right. So, now we're going to get into deployment, I have a Gist file here, I'll have the link in the links markdown file. And we're going to be using DigitalOcean. And this is just kind of the steps that are laid out for us. So, this link right here is a referral link that will give you $10 free. So, you can get either the one or two-month package absolutely free. You don't have to pay anything to follow along with this tutorial. So, we're going to create a Droplet, which is basically just a Linux server. We're going to log in with SSH, install node, clone our project from GitHub. So, we're going to have to push to GitHub, install any dependencies, set up PM2 which is a process manager that will keep our app running. So, even if the server restarts or anything, the app will still run, then we're going to just set up a simple firewall. We're going to set up NGINX, which is a webserver as a reverse proxy so that we can access our application through port 80 as opposed to having to go to 5000. And then we're going to add a domain and finally add an SSL with Let's Encrypt. All right. So, let's start off by going to DigitalOcean. You'll have to sign up. I'm already signed up and signed in. And this is the Control Panel. So, I'm going to create a new Droplet [no audio] So, up here, I'll pick our operating system, I'm going to use Ubuntu 18.04. And then for the plan, that link that I gave you is going to give you at least $10. So, we'll just go ahead and click that one. Now where it says authentication, you can choose to use a password but SSH is more secure where you get a public key and a private key on your local machine and then you put a public key on the server and then you don't even need a password to log in, it just goes by your machine. Now I already have some saved here. I'm on my iMac so I can use this. But if you're going to generate an SSH, just to show you real quick, I believe I have this article in the links file, but I'm just going to search for a DigitalOcean create SSH and this article here... Actually, it's this. So, basically you want to run ssh-keygen and it will ask you where you want to save it. So, basically you're going to save it in your home directory inside of a folder called .ssh. And by default, it'll be called id_rsa. And you'll get a public key and a private key. You can use a passphrase if you want, I usually don't, and then it will generate the key. So, just to show you mine, let me just open up new terminal here. [no audio] And I'm just going to do an ls to list out the contents of my home directory and then .ssh. So, you can see I have some keys here. What I'm using for DigitalOcean is the id_rsa_do. This is the private key. This is the public key. What you want to do is grab your public key and put it in DigitalOcean. So, we can use the cat command and go to home /.ssh/id_rsa, whatever yours is called, mine is do, and then .pub. And then it will print the key on the screen here. So, I'm going to just grab this and copy it. And what you would do is just say new SSH key, paste it in, and you'll get a little green check if it's formatted correctly and you can name it. So, I'm not going to do it because I already have one. I'm going to use my iMac. And then down here, we'll just rename the the droplet to let's say devcamper-api. And that's it. Now we can create our Droplet. [no audio] So, it's going to create, it just takes a couple seconds here, and then it will give us an IP address, and we should be able to SSH into our server. Now if you're on Windows, I believe using the standard Windows command prompt, you do have the SSH command available to you in Windows 10. If not, you can use Git Bash, which is what I usually use on Windows or you can use the Windows Subsystem for Linux or the Nushell. I haven't used the Nushell yet, but I'm sure it supports SSH. So, this is now created. I'm going to copy the IP and now I'm going to go into my terminal and I'm going to do SSH and I'm going to use the root@ and then the IP. So, we'll get this. You just want to say yes and now we're logged in. So, you can see this right here, root@devcamper-api. All right? And I'm just going to use the root user. If you want to create another user, you can. But I'm just going to use the root user. Now I'm just going to exit for a second because I want to show you something. If you try this... If you generated the SSH and it didn't work, if it says like public key denied or something like that, try this, try ssh-ad, and then the location of the private key. So, .ssh/id_rsa or whatever it is and you'll get this identity added and then try to log in again, sometimes that works. All right. So, we know we can now log into our server. So, let's just do that again. And now we're all set to start. In the next video, we're going to install Node.js on our server and we're going to push our app to GitHub and then clone it onto our server.


Prepare & Push To Github

All right, guys. So, we're now able to log in to our server. And what I want to do now is push our app to GitHub, and there's a couple of things that we need to do first. So, one, this config.env that has all of our API keys and our database URIs, stuff like that, this isn't going to get pushed to GitHub because I put it in the '.gitignore'. So, there's a few ways you can handle this. What I'm going to do is create a new file in config called config.env.env. And then just take all this stuff and put it inside here and then just get rid of the values that obviously we don't want people to see. So, we'll get rid of that, the GEOCODER_API_KEY, JWT_SECRET and then all of the S... Well, I guess we'll just get rid of the username and password and the stuff here. [mouse clicks] All right. I mean, you can get rid of everything if you want, but I think leaving this stuff is fine. So, we'll save this, and then this is what's going to be pushed to GitHub. Okay. And what we'll do is we'll create a readme that will tell them to change that. So, let's do that. In the root here, we're going to create a new file called readme.md. [no audio] And let's see. Oh, it already has. What the heck? Let me close that up. That's what we're going to add here. So, let's add a title at the top of DevCamper API. Actually, I want that preview open. So, this is just... [no audio] Let's see, Markdown: Open Preview. This is just extension that I have. [no audio] I want this split. [no audio] What's going on? There we go. It's just an extension that I have called Markdown previewer, I think that's what's called. Yeah, Auto-Open Markdown Preview if you're interested. So, let's go ahead, and we'll put an angle bracket here, and we'll say 'Backend API for the DevCamper [Author Typing] application, [Author Typing] which is a bootcamp [Author Typing] directory website.' And I'll probably change this later on. But, I mean, what I'm putting here now is fine for us to have. We're just going to tell the user to... Actually, let's put in here 'Usage', [Author Typing] and then we'll say that you have to 'Rename' the "config/config.env.env" to "config/config.env" and update the values/settings to your own. All right. And then let's do 'Install [Author Typing] Dependencies'. So, from here let's put in our triple backticks and 'npm install'. Okay, so that will install the dependencies, and then let's say, Run App. [Author Typing] So, we just want to put a comment here to say 'Run in dev mode' which is 'npm run dev'. And let's say 'Run in production mode is npm start.' All right. And then we'll just put the 'Version: 1.0.0', and the 'License: MIT'. And you could do more if you want. Actually, let's make this list. [Author Typing] There we go. All right. So, save that. And now you should be... you should have been making git commits throughout the course. But we want to make one last one. Let me just get out of here, and let's say 'git'. [Author Typing] I'm sorry, 'git add' all, and then 'git commit -m'. I'll just say 'Added readme and starter config'. All right. So, now I should be all set. Okay? So, everything is pushed to my local repository. Now, we want to create a GitHub repo [Author Typing] So, let's say 'New repository', and I'm going to call this 'devcamper-api'. And we'll say 'Backend for [Author Typing] devcamper Node app' or just 'app'. [Author Typing] And I'm going to make this private. I'll make it public later on after the course is released, but for now I'm going to make it private and create repository. And then I'm just going to grab this line here to add this as a remote repo. [no audio] Already exists, okay. That's because I already did this. So, this should be fine 'cause I called it the same thing. So, now we just want to push. I'm going to say 'git push'. Say 'git push origin master'. [no audio]. All right. And let's go back here and reload, and there we go. So, now our project is on GitHub. So, the next step is to clone it onto our server. So, that's what we'll do in the next video.


Clone Repo On Server

All right guys, so we have our application pushed to GitHub and we're ready to clone it onto our server. So, first thing I'm going to do while logged into our server is I'm going to run apt update, update our packages. Now if you're not logged in as root, you just want to run pseudo. So, basically if you look at the documentation here, I have pseudo for most of the commands, just in case you're not logged in as root and what we need to do before we clone the repo is install node. So, there's just a couple steps we need to take. We can install it with our aptitude package manager. However, we need to add the the repo to get the latest version of Node. So, we're going to copy this curl command right here and then on our server, let's go ahead and paste that in and run it. [no audio] And then once that's done we can run apt install nodejs. Yes. [no audio] And then both Node and NPM should then be installed on our server. [no audio] So, just to check we can say node --version npm --version and you can see that that's set up. Good. So, now let's make a directory. I'm going to make... What I usually do is make a directory called apps. And let's cd into apps. And then this is where we'll go ahead and clone the repo. Oops. So, what we need to do is go to our repository on GitHub and go right here, it says Clone or download. And we're going to use HTPPS as opposed to SSH because if we use SSH we have to put our keys on GitHub and you know, generate the keys in the server and stuff like that, which I don't want to do. So, I'm going to just copy the https and then let's do git clone and paste that in and it's just going to bring that. It's going to create a folder called devcamper-api with our stuff in it. Just have to add this password. [Author Typing] Just because we used https and then if I ls we have our devcamper-api folder. So, now let's cd into devcamper-api. And what we want to do now is take care of the config because if I do an ls of the config we have our .env.env, and that's that's not going to work. We need to change the name of that first. So, let's use the mv command to rename. Lets see config/config.env.env to config/config.env. All right. And then if we do an ls of config now you can see it's called, it's named correctly, but we need to add our values to it and you can do this with vm if you want. I'm going to use nano, which is a simple text editor and just open it up. Wait a minute. Oh it's... we need to go to conflict/ [Author Typing] here we go. All right, so let's add let's see. So, for the MONGO_URI, now we can just go into VS Code and grab the stuff that we need. So, I'm going to grab this. So, we'll copy that and then we should be able to just, oops what did I do. [no audio] Should be able to just paste this in with Ctrl V. [no audio] Here we go. So, this is a... you can see that's been that's pasted in. Next thing we need is the API Key. So, let's grab this. This is the GEOCODER API key so, copy that and paste that in. Next thing we want is the JWT_SECRET. So, grab that and paste that in. And then we want our email stuff. Now you'd probably use something like send grid in production which is a premium service, but I'm not going to get into that, so we're just going to stick with mail trap for this. Which isn't... It's not something you'd use in production [no audio] but you know, send grid. There's some other ones as well that are good for sending emails. [no audio] All right. So, paste that in and I think we should be all set as far as this file. So, let's do a Ctrl X or command X. And then Y for yes to save and then Enter and now we should be good. So, we need to install our dependencies. So, while we're in the root of devcamper-api let's run npm install. We're basically just doing the stuff that we instructed in our read me file. [no audio] Now if I try to run our app so npm start, you can see that we're getting a connection error for MongoDB. So, I'm going to Ctrl C to stop this. Now, the reason for this is because our database our MongoDB Atlas platform is only accepting connections from our from the local host or whatever your IP is because remember when we set that up, we set it to only use our IP unless you chose to connect from anywhere. So, we need to actually go to mongodb.com and sign in. [no audio] What is my thing? [Author Typing] That's not it. [Author Typing] All right, so let's see. We want to go over to... over on the side here Network Access, and I'll have to blur that out. So right now, it's only my local IP address. So, we want to add IP address and then grab the DigitalOcean one. I'm going to just copy that and then paste that in here and we can put a comment if we want. We'll just say Digital Ocean Prod Server and Confirm. It might take a second to do this. You can see it's pending, [no audio] but now we should be able to connect from the server. Hopefully. All right. So, let's go ahead and you can close that up and let's try it out. So, we'll go back to our server and run npm start. And there we go. So, now we're connected. And if I go to our IP address, just grab that and we go to port, so :5000, there's our API. So, it is now live on our droplets and we can go to the ap... the IP address with the port which obviously isn't what we want to do. We want to have this run on Port 80 so we don't have to add this. But in addition to that we don't want to just run the app like this. This is something you do in development. So, we need to set up something called PM2 which is a process manager that will keep our app running because right now it's just you know it's just hanging here and I can close it with Ctrl C if something happens to the server or I close, you know, close it up, it's just going to, it's not going to work anymore. So, in the next video we're going to set up PM2 process manager to keep our app running.


PM2 Process Manager Setup

All right. So in this video, we're going to install PM2 and make it so that our app will constantly run in the background. I just want to show you real quick. If we go to DigitalOcean, we go to our panel here from our API. And if we go to Snapshots, you can take a live snapshot at any time so that if something goes wrong, you can just go back to that point in time. So, let's actually create a snapshot here and we'll just say App cloned before PM2 or however you want to describe. We'll just go ahead and take that snapshot. And then if something goes wrong, like when we install PM2 two or something, we can just reverse back to it. All right. So, I just want to show you the PM2 website if you're interested in reading more about it. So, it's an advanced, production process manager for Node.js, and there's all kinds of documentation here. If you want to go through, I'll have this in the links file. Basically what we need to do is install it globally. So, let's go to our server, make sure you're logged into your server, not your local machine. And then we're going to npm install -g pm2. [no audio] So, once that's installed, let's clear this up. We should be able to run... Now, usually what we would do is run npm start. So, instead of doing that, let's do pm2 start and our main file is called server.js. So, we should be able to just do that and there we go. So, now our application is running and we have... our terminal is free. It's not like it's hanging there in the terminal, and we can do like pm2 status. If we ever want to see the status, we can do, we can restart it with pm2. Let's try pm2 server restart [no audio] or restart server. [Author Typing] And you would do pm2 stop server, pm2 start server, so you can see all the commands in the documentation. But just to show you this is still working, if we go back here and reload, there we go. Now, there is a command that we have to run if we want the app to start when the server starts. So, if we reboot the server and we want the app to just run automatically, then we have to run the command pm2 and then startup ubuntu. So, if we run that, let's see what happened here. [no audio] Oh, ubuntu. Okay, so let's see right here. You can see making a script booting at startup. So, this will enable it to boot up or start up when the system boots up. All right. So, that should be all set. And if you want to check it out and test it, you can do reboot and run that. That will actually reboot your droplet and you'll see that the app will still be running. Now, if we want to see any logs, we can do pm2 logs. And this will actually just start a stream of logs and you can see server running and so on. And if I go to our application and reload a couple times, and go back, you can see that it made the request. We got a 304 which is not modified. It just means that nothing was modified and it got the fonts file as well that it needed. Okay. And it made a get request to the index. If we go to \bootcamps or what is it? api\version1\bootcamps, and we look in our console, you can see that we made that request. All right? So, everything is good and if we want to get out of these logs we can just do Ctrl C. And our app is still running. Good. So, now with that set up, we want to take care of this... Oops, I closed it up. Let's open that back up. So, we'll grab the IP. So, we don't want to have to do port 5000. We don't want to have to do that. We want this to work when we hit just the IP. So, what we'll do is we'll install nginx which is a web server and set up a reverse proxy, so that when we hit port 80, it basically just kind of forwards it to 5000 or it reaches into 5000. And we're going to set up a firewall so that we can't even go to 5000 or any port other than 80 or other than 443, which is the port for SSL, and of course, the SSH port as well, which is 22. So, we'll start to do that in the next video.


NGINX Reverse Proxy Setup

so we'll say yes. And then to enable a Port or allow a Port, we can say ufw allow. We can put the Port number, but we can also just do SSH like that. So now if we do ufw status, 22 is allowed, which is the SSH port. So, if I go now, this is Port 80 because we don't have a Port attached. You can see it's not going to work, it's just going to keep going. If I go to Port 5000, not going to work, which is what I want. I don't want 5000 to work. However, I do want Port 80 to work. So, let's... in our terminal, let's say allow, and we could either do 80 or we can just do http because that's the Port. Now, if I do a status, now we can see Port 80 is allowed and if I try to go now to Port 80, it works. And then the only other thing I want to enable right now his https, which is 443. So, we can just say ufw allow https and if we do a status, now 443 is allowed. So, no other Ports are open and it's more secure now. So, next thing we want to do is create our reverse proxy and if we look in this document right here, so we already did all this. We're at this step here. We need to change the config file, the sites-available/default, and add this server block, add this to our server block. So, let's just grab this here. If you're not root, then you need to use sudo and paste that in. So, this is the file we want to edit and let's go down to the server block, which is this right here. And let's go ahead and get rid of... we can just get rid of all this [Author Typing] and then let's go down here under these comments and we can get rid of this. [Author Typing] We can get rid of... actually, we'll just get rid of everything here [Author Typing] and all we need in this server block is this right here. So, I'm going to grab this [mouse clicking] and we'll go ahead and just paste that in. Now, as far as the server name goes, whatever domain you're going to use, you want to put here. So, I'm using devcamper.io. So, I'm going to put in devcamper.io and then www.devcamper.io. [Author Typing] And then down here, we have [Author Typing] our localhost 5000. So, that should be fine. If you use a different Port, obviously you would put that Port, but this is what your server block should look like. So just your server name and then we have location/ proxy_pass and then your localhost 5000 and then just add these other headers down here and we should be good. So, let's 'command x' and 'yes', 'Enter' and now that saves. So, now we just want to restart the nginx service so we can say service. nginx restart and we can just check the installation or check the config files with nginx -t. And it says our con files syntax is okay, test is okay. So, let's go back to... let's see, where are we? Let's go back to our IP. No Port 5000 and reload, and there we go. So now it's running on just the IP and there's no need to do Port 5000 because we're using nginx as a reverse proxy. So, we're just about there. In the next video, we're going to set up our domain and then we should be all set. We'll have API running in production.


Domain, SSL & Wrap Up

Okay so now we're ready to add a domain. So, I use Namecheap for my domains, that's what I'd recommend. I have a referral link in the deployment documentation in the Markdown file. And you can see I have a devcamper.io domain so I'm going to manage that. And what you need, all you need to do here by default it's this Nameservers is going to be Namecheap BasicDNS but you want to choose Custom DNS. And then you just want to add these three named servers, so, ns1.digitalocean.com and then ns2 and ns3.digitalocean.com. And then click the 'Check', the green 'Check'. Now, this might take, it'll say it can take up to 48 hours to propagate, but it usually takes around 10 minutes or so. So just I would suggest doing this first. Okay, and then once you do that, you can go to DigitalOcean and go over to... Let's see, we want to go to networking and then we want to add a domain. So it's going to be [Author Typing] devcamper.io. So I'm going to add this domain. All right,and then what we want to do is add two A records. One is going to be for the host or the default devcamper.io and we do that with just an at symbol. And then you just want to select the correct droplet. So I'm going to select my API droplet, create record. Okay, and then we also want to set one for www as well and create record. [no audio] Okay, so now we should have those two A records. And now this should work if we go over and I go to devcamper.io, our API is now working. If I go www.devcamper.io, it still works, awesome, so we have our domain working and like I said, it might take 10 minutes or so for propagation, maybe a little more once you add these name servers. Mine worked right away because I did this the other day. So, this was already all set. Okay now I think since we did that so quickly, we'll just move on to add our SSL using Let's Encrypt. Which basically we just need to run a bunch of commands and those commands are right here. All right,so first thing we want to do is add the repository, the Certbot. So, we'll just copy this and let's go here. And we'll paste that in. Okay, so that will add the PPA, let's hit Enter. [no audio] All right, and let's see next thing, we want to do we'll go ahead and do the update for our packages. [Author Typing] Okay, and then we want to run this right here. We want to install this Python Certbot engine X. This makes everything really easy. I don't know why Ctrl + V isn't working but space that in. All right, we want to say yes. [no audio] Okay, and once that's installed, we want to run this right here. But obviously you want to put your domain name in here. So, let's clear that up and let's paste this in here and just change this [Author Typing] to devcamper.io. Make sure you use your own domain name [Author Typing] that, all right, So, it's going to ask for an email address [Author Typing] just going to use that and then we want to agree to the terms. "Will you be willing to share your email? No". Okay, so now it's obtaining a new certificate. [no audio] waiting for verification. [no audio] All right so for this here we have two options. One is and it's just asking if we wanted to automatically redirect to HTTPS. So,I mean this is up to you. If you want it to always go to HTTPS, you want to choose option 2. If not then choose option 1. So,I'm going to go ahead and just go with 1. Yeah, I'm just going to go with 1. It might be a good idea to go with 2 but I think that this is fine for us. Okay so that should be it. Now, this is going to be valid for 90 days and it it will renew but we can test the renewal process with running this renew command right here. So certbot renew renew and run a dry run. So let's try that out make sure that it will renew okay. [no audio] And... [no audio] Okay, so congratulations our renewal succeeded. And now if we go back to our browser and let's go to https.devcamper.io io and there we go. We can see we get the little lock connection is secure, and we have an SSL installed. All right so that's it. Our API is completely deployed. We go to a domain, we have an SSL certificate. I guess what we can do now is just run a little bit of... Run some tests, not actual tests, but we can make sure everything still works. So I'm going to use the devcamper prod environment which uses this domain, which I'm actually going to change. Let's change this to HTTPS. [Author Typing] And then let's see. We'll get all boot camps, make sure it works good. Let's grab a single ID and get a single boot camp. [Author Typing] Okay, so all that stuff seems to be working as far as fetching data. Let's try to log in as or let's register a new user. So,we'll we'll go to authentication,register user and I think we already have John Doe. Because remember we're still using the same database. What you might want to do is have a development database and a production database and have those two different values in your config. But let's just register me, I don't think I'm an actual user in the database. Okay, so now I get the token back and I should be logged in. So, let's go to create a new boot camp. And in the body I'll say Brad's bootcamp. Send camp and that worked. I shouldn't be able to do it again because I've already published a boot camp. And even if it let me, it still wouldn't let me because it's a duplicate name. All right, so that works. Let's see, we'll create a course for our boot camp. So, we'll grab the ID which I'll get from 'Get All Bootcamps'. And you can do your testing however you want. But I'm just going to grab that and go to courses and create course. Let's put this in here and then for the body, we'll just go ahead and create this course here, send. Okay, so that works. Let's create another course, we'll call it "Full Stack Web Development 2" and let's make it 8000 and send. Okay now what I want to do is get the single boot camp and see if the cost got calculated. So I'm going to copy the bootcamp ID. Go to Get Single Bootcamp, paste in our ID, send. And now if we look at let's see average costs, it's 9000, so the calculation is working. Now, let's try to add a review. So remember we have to be registered as a user to add a review. So I'm going to register a new user. Actually, let's log in as because I should have in the database user@gmail see if that works. So now we're logged in as a user and let's go to we need the bootcamp ID to review. So, I'm going to grab Brad's boot camp ID and go to review which is down here and add a review for a bootcamp. And we just need to pass in the bootcamp ID, that and then the body. We'll go ahead and just keep that, okay? [no audio] And now if we go to let's see get reviews for bootcamp [Author Typing] let's put in our boot camp ID for Brad's boot camp and there it is. All right, and if we look at the boot camp itself which is where is it the single [Author Typing] that's not the right ID. We'll just do Get All Bootcamps. I just want to make sure that the average rating, right here average rating 8. Okay so as far as I can tell everything is working. If something isn't,go ahead and leave something in the Q&A. And one of my Q&A people will take a look at it and let me know. And I'll have what I'll do is I'll have either an extra section or an extra video that will have like any bug fixes or anything like that because of course there's a chance that something went wrong somewhere. It's not like this is an API or an earn app that 5,10 people worked on or anything. I created it myself in a short amount of time. So, there might be something here and there. But I will take a look at it if there is. All right, so I really hope you enjoyed this course and I hope you learned a lot. I do plan on doing a front end to this API. Probably in my view course when that comes out, but I might even do it in react and angular. Maybe all three, I'm not really sure. But at least now you know how to build a pretty decent, pretty in-depth API with Node Express, MongoDB, Mongoose etc, so that's it. I hope you liked it and I'll see you in the next course.